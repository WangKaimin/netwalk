#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmallEiffel The GNU Eiffel Compiler
Release -0.74 Beta #18 (Monday March 4th 2002)
Copyright (C), 1994-2002 - LORIA - UHP - INRIA - FRANCE
Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
http://SmallEiffel.loria.fr
C Compiler options used: -pipe -O2 -I/usr/include/SDL -D_REENTRANT `sdl-config --libs`
*/

/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/base.h) contains all basic Eiffel
  type definitions.
  This file is automatically included in the header for all modes of
  compilation: -boost, -no_check, -require_check, -ensure_check, ...
  This file is also included in the header of any cecil file (when the
  -cecil option is used).
  This file is also included in the header file of C++ wrappers (when
  using the external "C++" clause).
*/
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <signal.h>
#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <float.h>
#include <setjmp.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#ifdef WIN32
#include <windows.h>
#else
#ifndef O_RDONLY
#include <sys/file.h>
#endif
#ifndef O_RDONLY
#define O_RDONLY 0000
#endif
#endif

/* Because ANSI C EXIT_* are not always defined: */
#ifndef EXIT_FAILURE
#define EXIT_FAILURE 1
#endif
#ifndef EXIT_SUCCESS
#define EXIT_SUCCESS 0
#endif

/*
   On Linux glibc systems, we need to use sig.* versions of jmp_buf,
   setjmp and longjmp to preserve the signal handling context.
   Currently, the way I figured to detect this is if _SIGSET_H_types has
   been defined in /usr/include/setjmp.h.
*/
#ifdef _SIGSET_H_types
#define JMP_BUF    sigjmp_buf
#define SETJMP(x)  sigsetjmp( (x), 1)
#define LONGJMP    siglongjmp
#else
#define JMP_BUF    jmp_buf
#define SETJMP(x)  setjmp( (x) )
#define LONGJMP    longjmp
#endif

/*
   Type to store reference objects Id:
 */
typedef int Tid;
typedef struct S0 T0;
struct S0{Tid id;};

/*
   The default channel used to print runtime error messages:
*/
#define SE_ERR stderr

/*
   Eiffel type INTEGER is #2:
*/
typedef int T2;
#define EIF_INTEGER T2
#define M2 (0)
#define EIF_INTEGER_BITS (CHAR_BIT*sizeof(int))
#define EIF_MINIMUM_INTEGER (INT_MIN)
#define EIF_MAXIMUM_INTEGER (INT_MAX)

/*
  Eiffel type CHARACTER is #3:
*/
typedef unsigned char T3;
#define EIF_CHARACTER T3
#define M3 (0)
#define EIF_CHARACTER_BITS (CHAR_BIT)
#define EIF_MINIMUM_CHARACTER_CODE (0)
#define EIF_MAXIMUM_CHARACTER_CODE (255)
#define T3code(x) ((T2)(x))
#define T3to_integer(x) ((T2)((char)(x)))
#define T3to_bit(x) (x)

/*
  Eiffel type REAL is #4:
*/
typedef float T4;
#define EIF_REAL T4
#define M4 (0.0)
#define EIF_REAL_BITS (CHAR_BIT*sizeof(float))
#define EIF_MINIMUM_REAL (-(FLT_MAX))
#define EIF_MAXIMUM_REAL (FLT_MAX)
#define T2toT4(x) ((T4)(x))

/*
  Eiffel type DOUBLE is #5:
*/
typedef double T5;
#define EIF_DOUBLE T5
#define M5 (0.0)
#define EIF_DOUBLE_BITS (CHAR_BIT*sizeof(double))
#define EIF_MINIMUM_DOUBLE (-(DBL_MAX))
#define EIF_MAXIMUM_DOUBLE (DBL_MAX)
#define T2toT5(x) ((T5)(x))
#define T4toT5(x) ((T5)(x))

/*
  Eiffel type BOOLEAN is #6:
*/
typedef char T6;
#define EIF_BOOLEAN T6
#define M6 (0)
#define EIF_BOOLEAN_BITS (CHAR_BIT)

/*
   Eiffel type POINTER is #8:
*/
typedef void* T8;
#define EIF_POINTER T8
#define M8 (NULL)
#define EIF_POINTER_BITS (CHAR_BIT*sizeof(void*))

/*
  To use type STRING on the C side:
*/
#define EIF_STRING T7*

/*
  Some Other EIF_* defined in ETL:
*/
#define eif_access(x) ((char*)(x))
#define EIF_REFERENCE T0*
#define EIF_OBJ T0*
#define EIF_OBJECT EIF_OBJ

/*
   Wrappers for `malloc' and `calloc':
*/
void* se_malloc(size_t size);
void* se_calloc(size_t nmemb, size_t size);

/*C Header Pass 1 :*/
typedef union _se_agent se_agent;
typedef struct _se_agent0 se_agent0;
typedef struct S57 T57;
typedef struct S114 T114;
typedef struct S135 T135;
typedef struct S130 T130;
typedef struct S47 T47;
typedef struct S75 T75;
typedef struct S41 T41;
typedef struct S43 T43;
typedef struct S87 T87;
typedef struct S83 T83;
typedef struct S117 T117;
typedef struct S126 T126;
typedef int T89;
typedef T0 T111;
typedef struct S54 T54;
typedef int T108;
typedef struct S102 T102;
typedef struct S107 T107;
typedef struct S121 T121;
typedef T0 T124;
typedef struct S120 T120;
typedef struct S74 T74;
typedef T0 T149;
typedef struct S53 T53;
typedef struct S50 T50;
typedef struct S122 T122;
typedef struct S151 T151;
typedef struct S77 T77;
typedef struct S51 T51;
typedef struct S97 T97;
typedef struct S99 T99;
typedef struct S80 T80;
typedef struct S140 T140;
typedef struct S118 T118;
typedef struct S113 T113;
typedef struct S55 T55;
typedef struct S7 T7;
typedef struct S65 T65;
typedef struct S128 T128;
typedef struct S105 T105;
typedef struct S68 T68;
typedef struct S129 T129;
typedef struct S153 T153;
typedef struct S45 T45;
typedef struct S96 T96;
typedef struct S39 T39;
typedef struct S127 T127;
typedef struct S98 T98;
typedef int T152;
typedef T0 T95;
typedef T0 T134;
typedef T0 T109;
typedef int T155;
typedef struct S104 T104;
typedef struct S131 T131;
typedef struct S28 T28;
typedef struct S112 T112;
typedef struct S67 T67;
typedef struct S137 T137;
typedef T0 T115;
typedef struct S22 T22;
typedef struct S64 T64;
typedef struct S16 T16;
typedef struct S125 T125;
typedef struct S86 T86;
typedef struct S138 T138;
typedef struct S146 T146;
typedef struct S106 T106;
typedef struct S66 T66;
typedef struct S116 T116;
typedef struct S132 T132;
typedef struct S136 T136;

/*C Header Pass 2 :*/
typedef T6*T82;
typedef T0**T49;
typedef T0**T76;
typedef T0**T69;
typedef T3*T9;
typedef T2*T85;
typedef T0**T133;

/*C Header Pass 3 :*/
extern T152 M152;
extern T155 M155;
struct S22{T5 _time_memory;};
int se_cmpT22(T22 o1,T22 o2);

/*C Header Pass 4 :*/
struct S57{Tid id;};
extern T57 M57;
void se_prinT57(T57**o);
struct S114{Tid id;T0* _main;};
extern T114 M114;
void se_prinT114(T114**o);
struct S135{Tid id;T0* _main;};
extern T135 M135;
void se_prinT135(T135**o);
struct S130{Tid id;T0* _score_table;T0* _tfr;T0* _tfw;};
extern T130 M130;
void se_prinT130(T130**o);
struct S47{Tid id;T0* _item;T2 _key;T0* _next;};
extern T47 M47;
void se_prinT47(T47**o);
struct S75{Tid id;T2 _upper2;T2 _upper1;T2 _lower2;T2 _lower1;T76 _storage;T2 _capacity;};
extern T75 M75;
void se_prinT75(T75**o);
struct S41{Tid id;T0* _linked_list;T0* _current_link;};
extern T41 M41;
void se_prinT41(T41**o);
struct S43{Tid id;T0* _item;T0* _next;};
extern T43 M43;
void se_prinT43(T43**o);
struct S87{Tid id;T0* _item;T0* _next;};
extern T87 M87;
void se_prinT87(T87**o);
struct S83{Tid id;T85 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T83 M83;
void se_prinT83(T83**o);
struct S117{Tid id;T6 _has_focus;T0* _signal_table;T2 _offsetx;T2 _offsety;T2 _width;T2 _height;T0* _widget_list;T0* _focus_widget;T0* _preset_lb;T0* _wrap_cb;T0* _width_tb;T0* _height_tb;T0* _setting;T0* _preset;T0* _preset_list;};
extern T117 M117;
void se_prinT117(T117**o);
void se_prinT82(T82*o);
struct S126{Tid id;T6 _has_focus;T0* _signal_table;T2 _offsetx;T2 _offsety;T2 _width;T2 _height;T6 _value;};
extern T126 M126;
void se_prinT126(T126**o);
void se_prinT49(T49*o);
extern T89 M89;
void se_prinT89(T89*o);
void se_prinT111(T111**o);
struct S54{Tid id;T0* _score_file;T0* _preset_list;T0* _mainttf;T0* _bigttf;T0* _mainfont;T0* _bigfont;T0* _default_preset;};
extern T54 M54;
void se_prinT54(T54**o);
extern T108 M108;
void se_prinT108(T108*o);
struct S102{Tid id;T0* _first;};
extern T102 M102;
void se_prinT102(T102**o);
T0*new_tuple102(T0* i1);
struct S107{Tid id;T6 _has_focus;T0* _signal_table;T2 _offsetx;T2 _offsety;T2 _width;T2 _height;T0* _string;T0* _img;};
extern T107 M107;
void se_prinT107(T107**o);
struct S121{Tid id;T0* _item;T0* _next;};
extern T121 M121;
void se_prinT121(T121**o);
void se_prinT124(T124**o);
struct S120{Tid id;T6 _has_focus;T0* _signal_table;T2 _offsetx;T2 _offsety;T2 _width;T2 _height;T0* _string_list;T0* _string;T2 _list_i;T0* _textimg;};
extern T120 M120;
void se_prinT120(T120**o);
void se_prinT76(T76*o);
void se_prinT149(T149**o);
struct S53{Tid id;T6 _is_connected;T8 _ptr;};
extern T53 M53;
void se_prinT53(T53**o);
struct S50{Tid id;T6 _is_connected;T8 _ptr;};
extern T50 M50;
void se_prinT50(T50**o);
struct S122{Tid id;T0* _linked_list;T0* _current_link;};
extern T122 M122;
void se_prinT122(T122**o);
struct S151{Tid id;T0* _linked_list;T0* _current_link;};
extern T151 M151;
void se_prinT151(T151**o);
struct S77{Tid id;T2 _seed;T0* _iv;T2 _iy;};
extern T77 M77;
void se_prinT77(T77**o);
struct S51{Tid id;T2 _to_integer;T2 _to_gfx_integer;T8 _pointer;};
extern T51 M51;
void se_prinT51(T51**o);
struct S97{Tid id;T6 _has_focus;T0* _signal_table;T2 _offsetx;T2 _offsety;T2 _width;T2 _height;T0* _widget_list;T0* _focus_widget;T0* _name_tb;};
extern T97 M97;
void se_prinT97(T97**o);
struct S99{Tid id;T6 _has_focus;T0* _signal_table;T2 _offsetx;T2 _offsety;T2 _width;T2 _height;T0* _widget_list;T0* _focus_widget;T2 _row_count;T0* _score_list;};
extern T99 M99;
void se_prinT99(T99**o);
struct S80{Tid id;T82 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T80 M80;
void se_prinT80(T80**o);
struct S140{Tid id;T2 _item;};
extern T140 M140;
void se_prinT140(T140**o);
struct S118{Tid id;T2 _upper;T0* _first_link;T0* _last_link;T2 _mem_idx;T0* _mem_lnk;};
extern T118 M118;
void se_prinT118(T118**o);
struct S113{Tid id;T6 _has_focus;T0* _signal_table;T2 _offsetx;T2 _offsety;T2 _width;T2 _height;T0* _string;T0* _img;};
extern T113 M113;
void se_prinT113(T113**o);
struct S55{Tid id;T6 _push_back_flag;T0* _path;T8 _input_stream;T2 _memory;};
extern T55 M55;
void se_prinT55(T55**o);
void se_prinT69(T69*o);
struct S65{Tid id;T0* _name;T0* _setting;T0* _hiscore;};
extern T65 M65;
void se_prinT65(T65**o);
struct S128{Tid id;T0* _main;};
extern T128 M128;
void se_prinT128(T128**o);
struct S105{Tid id;T2 _upper;T0* _first_link;T0* _last_link;T2 _mem_idx;T0* _mem_lnk;};
extern T105 M105;
void se_prinT105(T105**o);
struct S68{Tid id;T2 _width;T2 _height;T6 _wrap;};
extern T68 M68;
void se_prinT68(T68**o);
struct S129{Tid id;T0* _main;};
extern T129 M129;
void se_prinT129(T129**o);
struct S153{Tid id;T9 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T153 M153;
void se_prinT153(T153**o);
struct S45{Tid id;T49 _buckets;T2 _capacity;T2 _count;T2 _cache_user;T0* _cache_node;T2 _cache_buckets;};
extern T45 M45;
void se_prinT45(T45**o);
struct S96{Tid id;T0* _name;T2 _score;T2 _time;};
extern T96 M96;
void se_prinT96(T96**o);
struct S7{Tid id;T9 _storage;T2 _count;T2 _capacity;};
extern T7 M7;
struct S39{Tid id;T2 _upper;T0* _first_link;T0* _last_link;T2 _mem_idx;T0* _mem_lnk;};
extern T39 M39;
void se_prinT39(T39**o);
struct S127{Tid id;T0* _main;};
extern T127 M127;
void se_prinT127(T127**o);
void se_prinT9(T9*o);
struct S98{Tid id;T6 _has_focus;T0* _signal_table;T2 _offsetx;T2 _offsety;T2 _width;T2 _height;T2 _text_width;T2 _text_height;T0* _string;T2 _cursor;T0* _textimg;};
extern T98 M98;
void se_prinT98(T98**o);
void se_prinT152(T152*o);
void se_prinT95(T95**o);
void se_prinT134(T134**o);
void se_prinT109(T109**o);
void se_prinT155(T155*o);
struct S104{Tid id;T0* _name;T0* _level_l;T0* _name_l;T0* _time_l;T0* _score_l;};
extern T104 M104;
void se_prinT104(T104**o);
struct S131{Tid id;T133 _buckets;T2 _capacity;T2 _count;T2 _cache_user;T0* _cache_node;T2 _cache_buckets;};
extern T131 M131;
void se_prinT131(T131**o);
struct S28{Tid id;T2 _y;T2 _x;T2 _type;T2 _i1;T2 _kmod;};
extern T28 M28;
void se_prinT28(T28**o);
struct S112{Tid id;T0* _main;};
extern T112 M112;
void se_prinT112(T112**o);
struct S67{Tid id;T0* _item;T0* _next;};
extern T67 M67;
void se_prinT67(T67**o);
struct S137{Tid id;T0* _main;};
extern T137 M137;
void se_prinT137(T137**o);
void se_prinT115(T115**o);
extern T22 M22;
void se_prinT22(T22*o);
struct S74{Tid id;T2 _type;T0* _neighbour;T2 _y;T2 _x;T6 _is_connected;T2 _neighbour_count;};
extern T74 M74;
void se_prinT74(T74**o);
struct S64{Tid id;T69 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T64 M64;
void se_prinT64(T64**o);
struct S16{Tid id;T0* _io_score;T0* _board;T0* _current_preset;T0* _current_setting;T2 _seed;T2 _move_count;T0* _new_game_button;T0* _options_button;T0* _hs_button;T0* _quit_button;T0* _options_window;T0* _newhs_window;T0* _hs_window;T0* _widget_list;T2 _elapsed_seconds;T2 _elapsed_ticks;T2 _last_ticks;T2 _game_state;T0* _current_window;T0* _move_image;T0* _best_image;T0* _time_image;T0* _server_bottom;T0* _server_top;T0* _connected_pipe_color;T0* _disconnected_pipe_color;T0* _connected_terminal_color;T0* _disconnected_terminal_color;T0* _open_list;T0* _rand;T2 _best;};
extern T16 M16;
void se_prinT16(T16**o);
struct S125{Tid id;T0* _main;};
extern T125 M125;
void se_prinT125(T125**o);
struct S86{Tid id;T2 _upper;T0* _first_link;T0* _last_link;T2 _mem_idx;T0* _mem_lnk;};
extern T86 M86;
void se_prinT86(T86**o);
struct S138{Tid id;T0* _main;};
extern T138 M138;
void se_prinT138(T138**o);
void se_prinT85(T85*o);
struct S146{Tid id;T0* _path;T8 _output_stream;};
extern T146 M146;
void se_prinT146(T146**o);
struct S106{Tid id;T0* _item;T0* _next;};
extern T106 M106;
void se_prinT106(T106**o);
struct S66{Tid id;T2 _upper;T0* _first_link;T0* _last_link;T2 _mem_idx;T0* _mem_lnk;};
extern T66 M66;
void se_prinT66(T66**o);
struct S116{Tid id;T0* _main;};
extern T116 M116;
void se_prinT116(T116**o);
struct S132{Tid id;T0* _item;T0* _key;T0* _next;};
extern T132 M132;
void se_prinT132(T132**o);
struct S136{Tid id;T0* _main;};
extern T136 M136;
void se_prinT136(T136**o);
void se_prinT133(T133*o);
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/no_check.h) is automatically included
  when `run_control.no_check' is true (ie. all modes except mode -boost).
*/
#define SE_NO_CHECK 1

void se_prinT0(T0**o);
void se_prinT2(EIF_INTEGER*o);
void se_prinT3(EIF_CHARACTER*o);
void se_prinT4(EIF_REAL*o);
void se_prinT5(EIF_DOUBLE*o);
void se_prinT6(EIF_BOOLEAN*o);
void se_prinT7(EIF_STRING*o);
void se_prinT8(EIF_POINTER*o);

/*
   This type is used to store a position in some Eiffel source file.
   It must be compatible with the implementation of class POSITION.
*/
typedef unsigned int se_position;

EIF_INTEGER se_position2line(se_position position);
EIF_INTEGER se_position2column(se_position position);
EIF_INTEGER se_position2path_id(se_position position);

/*
  To be able to print a stack frame in a human readable format :
*/
typedef struct _se_frame_descriptor se_frame_descriptor;
struct _se_frame_descriptor {
  char* name; /* Eiffel name of the routine. */
  int use_current; /* Flag is 1 when this routine use Current. */
  int local_count; /* Number of C variables to print. */
  char* local_format; /* Format/type information. */
  int assertion_flag; /* 1 when assertions can be checked. */
};

/*
  To keep the track of execution in order to be able to print a
  dump when things goes wrong :
*/
typedef struct _se_dump_stack se_dump_stack;
struct _se_dump_stack {
  se_frame_descriptor* fd;
  void** current; /* NULL when not used. */
  se_position p; /* The current position. */
  se_dump_stack* caller; /* Back to the caller. */
  void*** locals;
};
extern se_dump_stack* se_dst;
int se_stack_size(se_dump_stack* ds);
void se_print_run_time_stack(void);
int se_print_one_frame(se_dump_stack*ds);

extern int se_rspf;
extern int se_require_uppermost_flag;
extern int se_require_last_result;
int se_rci(se_dump_stack*caller,void*C);
void error0(char*m,char*vv);
void error1(char*m,se_position position);
void error2(T0*o,se_position position);
T0* vc(void*o,se_position position);
T0* ci(int id,void*o,se_position position);
void ac_req(int v,char*vv);
void ac_ens(int v,char*vv);
void ac_inv(int v,char*vv);
void ac_liv(int v,char*vv);
void ac_insp(int v);
int ac_lvc(int lc,int lv1,int lv2);
void ac_civ(int v,char*vv);
void se_evobt(void*o,se_position position);
void se_signal_handler(int sig);
void se_gc_check_id(void*o,int id);
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/trace.h) is automatically included when
  `run_control.no_check' is true (ie. all modes except -boost).
  This file comes after no_check.[hc] to implements the -trace flag.
*/
#ifdef SE_WEDIT
se_position se_trace(se_position p);
#elif SE_TRACE
#define SE_DB_BUFMAX 512
typedef struct _se_breakpoint se_breakpoint;
struct _se_breakpoint {
  int name_flag; char name[SE_DB_BUFMAX];
  int file_flag; char file[SE_DB_BUFMAX];
  int line_flag; int line_minimum; int line_maximum;
  int stack_flag; int stack_limit; int stack_automatic;
  se_breakpoint* next; /* The next one or or NULL. */
};
void se_trace(se_dump_stack*ds,se_position p);
void se_db_signal_handler(int sig);
void se_db_back(se_dump_stack*ds,se_position p);
void sedb_breakpoint(se_dump_stack*ds);
#endif
#define FSOC_SIZE 8192
#define RSOC_SIZE 32768
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
--                       http://SmallEiffel.loria.fr
--
*/
/*
   This file (SmallEiffel/sys/runtime/gc_lib.h) is automatically included
   when the Garbage Collector is used (default, unless option -no_gc has
   been selected).
*/
#define SE_GC_LIB 1

#define SE_GC_LOW_MEMORY_STRATEGY 0
#define SE_GC_HIGH_MEMORY_STRATEGY 1
#define SE_GC_DEFAULT_MEMORY_STRATEGY 2
extern int se_gc_strategy;


#define RSOH_UNMARKED 15253
#define RSOH_FREE 1
#define RSOH_MARKED 2


#define FSOH_UNMARKED 1
#define FSOH_MARKED 2

/* To codify the state and the type of some Memory Chunk, we are
   using the following definitions :
*/
#define FSO_FREE_CHUNK  (-2)
#define RSO_FREE_CHUNK  (-1)
#define RSO_USED_CHUNK  ( 0)
#define FSO_STORE_CHUNK ( 1)
#define FSO_USED_CHUNK  ( 2)
#define FREE_CHUNK(x) ((x)<0)

/* Minimum size for a store area in a ReSizable Objects Chunk :
 */
#define RSOC_MIN_STORE 512

/* The default channel used to print -gc_info flag information :
*/
#define SE_GCINFO SE_ERR

extern int collector_counter; /* MEMORY.collector_counter */

typedef struct s_mch mch; /* Memory Chunk Header. */
typedef struct s_fsoc fsoc; /* Fixed Size Objects Chunk. */
typedef union u_rsoh rsoh; /* ReSizable Object Header. */
typedef struct s_fll_rsoh fll_rsoh;
typedef struct s_rsoc rsoc; /* ReSizable Objects Chunk. */
typedef struct s_na_env na_env; /* Native Array ENVironment. */


struct s_mch{
  unsigned int size; /* In number of bytes (actual argument of malloc).*/
  int state_type; /* One value in : RSO_USED_CHUNK,
                     FREE_CHUNK, FSO_STORE_CHUNK, FSO_USED_CHUNK */
  void(*amfp)(mch*,void*); /* Align Mark Function Pointer. */
  void(*swfp)(mch*); /* SWeep Function Pointer. */
};

struct s_fsoc{
  mch header; /* Common header for fsoc and rsoc. */
  fsoc* next; /* The next one when in free list (fsocfl). */
  int count_minus_one;
  double first_object;
};

typedef struct _rso_header rso_header;

struct _rso_header{
    int size;
    int magic_flag;     /* RSOH_MARKED when used,
			   RSOH_FREE when free,
			   else RSOH_UNMARKED */
};

union u_rsoh{
  rso_header header;
  double padding;
  };

struct s_fll_rsoh {
  rso_header rsoh_field;
  fll_rsoh* nextflol;
};

struct s_rsoc{
  mch header; /* Common header for fsoc and rsoc. */
  int isize; /* Initial size (at malloc time) to detect splitted chunks. */
  rsoc* next; /* The next one when in free list (rsocfl). */
  fll_rsoh*free_list_of_large; /* Intra. free list. */
  na_env*nae;
  rsoh first_header;
};

struct s_na_env{
  int store_left;
  rsoh* store;
  rsoc*store_chunk;
  rsoc*chunk_list;
  void (*gc_mark)(T0*);
};

extern void**stack_bottom;
extern mch**gcmt;
extern int gcmt_max;
extern int gcmt_used;
extern int gc_is_off;
extern fsoc* fsocfl;
extern unsigned int fsoc_count;
extern unsigned int rsoc_count;
extern void*gcmt_tail_addr;

void gc_sweep(void);
void gc_mark(void*p);
int gc_stack_size(void);
int garbage_delayed(void);
void gc_update_ceils(void);
char*new_na(na_env*nae,int size);
int fsocfl_count(void);
int rsocfl_count(void);
void gc_dispose_before_exit(void);
void mark_stack_and_registers (void);
fsoc* gc_fsoc_get1(void);
fsoc* gc_fsoc_get2(void);
struct _se_agent0{Tid id;void*(*afp)(se_dump_stack*,se_agent*);};
typedef struct _se_agent12 se_agent12;
struct _se_agent12{Tid id;void(*afp)(se_dump_stack*,se_agent12*,T0*);T0* C;};
typedef struct _se_agent11 se_agent11;
struct _se_agent11{Tid id;void(*afp)(se_dump_stack*,se_agent11*,T0*,T0*);T0* C;};
typedef struct _se_agent10 se_agent10;
struct _se_agent10{Tid id;void(*afp)(se_dump_stack*,se_agent10*,T0*);};
typedef struct _se_agent9 se_agent9;
struct _se_agent9{Tid id;void(*afp)(se_dump_stack*,se_agent9*,T0*);};
typedef struct _se_agent8 se_agent8;
struct _se_agent8{Tid id;void(*afp)(se_dump_stack*,se_agent8*,T0*);};
typedef struct _se_agent7 se_agent7;
struct _se_agent7{Tid id;void(*afp)(se_dump_stack*,se_agent7*,T0*);T0* C;};
typedef struct _se_agent6 se_agent6;
struct _se_agent6{Tid id;void(*afp)(se_dump_stack*,se_agent6*,T0*);T0* C;T2 a2;T2 a3;};
typedef struct _se_agent5 se_agent5;
struct _se_agent5{Tid id;void(*afp)(se_dump_stack*,se_agent5*,T0*);T0* C;T2 a2;T2 a3;};
typedef struct _se_agent4 se_agent4;
struct _se_agent4{Tid id;void(*afp)(se_dump_stack*,se_agent4*,T0*);T0* C;T2 a2;T2 a3;};
typedef struct _se_agent3 se_agent3;
struct _se_agent3{Tid id;void(*afp)(se_dump_stack*,se_agent3*,T0*);T0* C;};
typedef struct _se_agent2 se_agent2;
struct _se_agent2{Tid id;void(*afp)(se_dump_stack*,se_agent2*,T0*);};
typedef struct _se_agent1 se_agent1;
struct _se_agent1{Tid id;void(*afp)(se_dump_stack*,se_agent1*,T0*);};
union _se_agent{T0 s0;se_agent0 u0;se_agent12 u12;se_agent11 u11;se_agent10 u10;se_agent9 u9;se_agent8 u8;se_agent7 u7;se_agent6 u6;se_agent5 u5;se_agent4 u4;se_agent3 u3;se_agent2 u2;se_agent1 u1;};
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/agents.h) is automatically included
  when agent support is used in the live code.
*/
#define SE_AGENTS 1
#define EIF_AGENT se_agent*

#ifdef SE_NO_CHECK
se_agent* new_agent(Tid id);
#else
se_agent* new_agent(void);
#endif

#ifdef SE_GC_LIB

typedef struct B_agent gc_agent;

struct B_agent
{
  se_agent object;
  union
  {
    int flag;
    gc_agent *next;
  } header;
};

extern gc_agent *store_agent;
extern gc_agent *gc_free_agent;
extern int       store_left_agent;
extern fsoc     *store_chunk_agent;
extern fsoc      H_agent;
extern int       gc_info_nb_agent;

void gc_mark_agent (/*agent*/T0* o);
void gc_align_mark_agent(fsoc *c, gc_agent* a);
void gc_sweep_agent(fsoc *c);

#endif
/*agent*/T0*agent12(se_dump_stack*caller,T0* C);
/*agent*/T0*agent11(se_dump_stack*caller,T0* C);
/*agent*/T0*agent10(se_dump_stack*caller);
/*agent*/T0*agent9(se_dump_stack*caller);
/*agent*/T0*agent8(se_dump_stack*caller);
/*agent*/T0*agent7(se_dump_stack*caller,T0* C);
/*agent*/T0*agent6(se_dump_stack*caller,T0* C,T2 a2,T2 a3);
/*agent*/T0*agent5(se_dump_stack*caller,T0* C,T2 a2,T2 a3);
/*agent*/T0*agent4(se_dump_stack*caller,T0* C,T2 a2,T2 a3);
/*agent*/T0*agent3(se_dump_stack*caller,T0* C);
/*agent*/T0*agent2(se_dump_stack*caller);
/*agent*/T0*agent1(se_dump_stack*caller);
void call_r0v(se_dump_stack*caller,/*agent*/T0*a,T0* a1);
void call_r0r0v(se_dump_stack*caller,/*agent*/T0*a,T0* a1,T0* a2);
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/basic_io.h) is automatically
  included when some external "SmallEiffel" basic_io_* feature is used.
*/

#define basic_io_stdin (stdin)
#define basic_io_stdout (stdout)
#define basic_io_stderr (stderr)
#define basic_io_eof (EOF)
#define basic_io_text_file_read_open(p) (fopen(((char*)(p)),"r"))
#define basic_io_text_file_write_open(p) (fopen(((char*)(p)),"w"))
#define basic_io_text_file_write_append(p) (fopen(((char*)(p)),"a"))
#define basic_io_text_file_read_write_open(p) (fopen(((char*)(p)),"r+"))
#define basic_io_text_file_read_write_append(p) (fopen(((char*)(p)),"a+"))
#define basic_io_binary_file_read_open(p) (fopen(((char*)(p)),"rb"))
#define basic_io_binary_file_write_open(p) (fopen(((char*)(p)),"wb"))
#define basic_io_binary_file_write_append(p) (fopen(((char*)(p)),"ab"))
#define basic_io_fclose(p) (fclose((FILE*)(p)))
#define basic_io_flush(p) (fflush((FILE*)(p)))
#define basic_io_getc(f) (getc(((FILE*)(f))))
#define basic_io_putc(b, f) (putc((b),((FILE*)(f))))
#define basic_io_feof(f) (feof(((FILE*)(f))))
#define basic_io_rename(o, n) (rename(((char*)(o)),((char*)(n))))
#define basic_io_remove(f) (remove(((char*)(f))))
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/basic_time.h) is automatically
  included when some external "SmallEiffel" basic_time_* feature is
  used (i.e. in live code).
*/
#include <time.h>

#ifdef WIN32
#include <windows.h>
#endif

#define basic_time_time (_basic_time_time())
EIF_DOUBLE _basic_time_time(void);
EIF_DOUBLE basic_time_difftime(EIF_DOUBLE t1, EIF_DOUBLE t2);
EIF_INTEGER basic_time_getyear(EIF_DOUBLE t, EIF_INTEGER m);
EIF_INTEGER basic_time_getmonth(EIF_DOUBLE t, EIF_INTEGER m);
EIF_INTEGER basic_time_getday(EIF_DOUBLE t, EIF_INTEGER m);
EIF_INTEGER basic_time_gethour(EIF_DOUBLE t, EIF_INTEGER m);
EIF_INTEGER basic_time_getminute(EIF_DOUBLE t, EIF_INTEGER m);
EIF_INTEGER basic_time_getsecond(EIF_DOUBLE t, EIF_INTEGER m);
EIF_INTEGER basic_time_getyday(EIF_DOUBLE t, EIF_INTEGER m);
EIF_INTEGER basic_time_getwday(EIF_DOUBLE t, EIF_INTEGER m);
EIF_BOOLEAN basic_time_is_summer_time_used(EIF_DOUBLE t);
EIF_DOUBLE basic_time_mktime(EIF_INTEGER year, EIF_INTEGER mon,
			     EIF_INTEGER mday, EIF_INTEGER hour,
			     EIF_INTEGER min,  EIF_INTEGER sec);
void basic_time_add_second(EIF_DOUBLE *t, int s);
extern unsigned int fsoc_count_ceil;
extern unsigned int rsoc_count_ceil;
T6 r6_ix_not(se_dump_stack*caller,T6 C);
T6 r6_px_or(se_dump_stack*caller,T6 C,T6 a1);
T6 r6_px_and(se_dump_stack*caller,T6 C,T6 a1);
T6 r6_px_xor(se_dump_stack*caller,T6 C,T6 a1);
T6 r3_px_6061(se_dump_stack*caller,T3 C,T3 a1);
T6 r3is_equal(se_dump_stack*caller,T3 C,T3 a1);
T6 r3is_digit(se_dump_stack*caller,T3 C);
T6 r3is_separator(se_dump_stack*caller,T3 C);
T6 r3in_range(se_dump_stack*caller,T3 C,T3 a1,T3 a2);
T6 r3_px_6261(se_dump_stack*caller,T3 C,T3 a1);
T2 r3value(se_dump_stack*caller,T3 C);
T6 r3_px_60(se_dump_stack*caller,T3 C,T3 a1);
T2 r3decimal_value(se_dump_stack*caller,T3 C);
T6 r2is_equal(se_dump_stack*caller,T2 C,T2 a1);
T6 r2divisible(se_dump_stack*caller,T2 a1);
T6 r2in_range(se_dump_stack*caller,T2 C,T2 a1,T2 a2);
T0* r2to_string(se_dump_stack*caller,T2 C);
extern T0*oBC2tmp_string;
extern int fBC2tmp_string;
T0* r2tmp_string(se_dump_stack*caller);
T3 r2digit(se_dump_stack*caller,T2 C);
T2 r2hash_code(se_dump_stack*caller,T2 C);
void r2append_in(se_dump_stack*caller,T2 C,T0* a1);
T6 r82fast_memcmp(se_dump_stack*caller,T82 C,T82 a1,T2 a2);
void r82set_all_with(se_dump_stack*caller,T82 C,T6 a1,T2 a2);
T6 r82is_not_null(se_dump_stack*caller,T82 C);
T6 r82all_default(se_dump_stack*caller,T82 C,T2 a1);
void r82copy_from(se_dump_stack*caller,T82 C,T82 a1,T2 a2);
void r49set_all_with(se_dump_stack*caller,T49 C,T0* a1,T2 a2);
T6 r76safe_equal(se_dump_stack*caller,T0* a1,T0* a2);
void r76clear_all(se_dump_stack*caller,T76 C,T2 a1);
T6 r76is_not_null(se_dump_stack*caller,T76 C);
T6 r76memcmp(se_dump_stack*caller,T76 C,T76 a1,T2 a2);
void r76copy_from(se_dump_stack*caller,T76 C,T76 a1,T2 a2);
T69 r69realloc(se_dump_stack*caller,T69 C,T2 a1,T2 a2);
T6 r69fast_memcmp(se_dump_stack*caller,T69 C,T69 a1,T2 a2);
T6 r69is_not_null(se_dump_stack*caller,T69 C);
void r69copy_from(se_dump_stack*caller,T69 C,T69 a1,T2 a2);
void r9copy_slice(se_dump_stack*caller,T9 C,T2 a1,T9 a2,T2 a3,T2 a4);
T9 r9realloc(se_dump_stack*caller,T9 C,T2 a1,T2 a2);
void r9set_all_with(se_dump_stack*caller,T9 C,T3 a1,T2 a2);
T6 r9fast_memcmp(se_dump_stack*caller,T9 C,T9 a1,T2 a2);
T6 r9fast_has(se_dump_stack*caller,T9 C,T3 a1,T2 a2);
void r9copy_at(se_dump_stack*caller,T9 C,T2 a1,T9 a2,T2 a3);
T6 r9is_not_null(se_dump_stack*caller,T9 C);
T6 r9all_default(se_dump_stack*caller,T9 C,T2 a1);
void r9copy_from(se_dump_stack*caller,T9 C,T9 a1,T2 a2);
T6 r85fast_memcmp(se_dump_stack*caller,T85 C,T85 a1,T2 a2);
void r85set_all_with(se_dump_stack*caller,T85 C,T2 a1,T2 a2);
T6 r85is_not_null(se_dump_stack*caller,T85 C);
T6 r85all_default(se_dump_stack*caller,T85 C,T2 a1);
void r85copy_from(se_dump_stack*caller,T85 C,T85 a1,T2 a2);
void r133set_all_with(se_dump_stack*caller,T133 C,T0* a1,T2 a2);
void r7copy(se_dump_stack*caller,T7* C,T0* a1);
T0* r7substring(se_dump_stack*caller,T7* C,T2 a1,T2 a2);
T2 r7upper(se_dump_stack*caller,T7* C);
void r7put(se_dump_stack*caller,T7* C,T3 a1,T2 a2);
void r7remove_between(se_dump_stack*caller,T7* C,T2 a1,T2 a2);
T6 r7is_equal(se_dump_stack*caller,T7* C,T0* a1);
void r7insert_character(se_dump_stack*caller,T7* C,T3 a1,T2 a2);
T3 r7item(se_dump_stack*caller,T7* C,T2 a1);
extern T0*oBC7string_buffer;
extern int fBC7string_buffer;
T0* r7string_buffer(se_dump_stack*caller);
extern T0*oBC7split_buffer;
extern int fBC7split_buffer;
T0* r7split_buffer(se_dump_stack*caller);
T0* r7split(se_dump_stack*caller,T7* C);
T6 r7valid_index(se_dump_stack*caller,T7* C,T2 a1);
void r7append(se_dump_stack*caller,T7* C,T0* a1);
void r7set_count(se_dump_stack*caller,T7* C,T2 a1);
T6 r7is_integer(se_dump_stack*caller,T7* C);
void r7make(se_dump_stack*caller,T7* C,T2 a1);
void r7remove(se_dump_stack*caller,T7* C,T2 a1);
T6 r7is_empty(se_dump_stack*caller,T7* C);
void r7extend(se_dump_stack*caller,T7* C,T3 a1);
T0* r7_px_43(se_dump_stack*caller,T7* C,T0* a1);
T2 r7hash_code(se_dump_stack*caller,T7* C);
T6 r7has(se_dump_stack*caller,T7* C,T3 a1);
T6 r7_px_60(se_dump_stack*caller,T7* C,T0* a1);
T6 r7standard_is_equal(se_dump_stack*caller,T7* C,T0* a1);
T2 r7to_integer(se_dump_stack*caller,T7* C);
void r7append_character(se_dump_stack*caller,T7* C,T3 a1);
T3 r7first(se_dump_stack*caller,T7* C);
void r7clear(se_dump_stack*caller,T7* C);
T8 r7to_external(se_dump_stack*caller,T7* C);
T0* r7twin(se_dump_stack*caller,T7* C);
void r7split_in(se_dump_stack*caller,T7* C,T0* a1);
void r7swap(se_dump_stack*caller,T7* C,T2 a1,T2 a2);
extern se_frame_descriptor se_ifd7;
T7*se_i7(se_dump_stack*caller,T7*C);
void r83copy(se_dump_stack*caller,T83* C,T0* a1);
void r83clear_all(se_dump_stack*caller,T83* C);
T2 r83count(se_dump_stack*caller,T83* C);
void r83put(se_dump_stack*caller,T83* C,T2 a1,T2 a2);
T6 r83is_equal(se_dump_stack*caller,T83* C,T0* a1);
T2 r83item(se_dump_stack*caller,T83* C,T2 a1);
T6 r83valid_index(se_dump_stack*caller,T83* C,T2 a1);
void r83make(se_dump_stack*caller,T83* C,T2 a1,T2 a2);
void r83set_all_with(se_dump_stack*caller,T83* C,T2 a1);
T6 r83standard_is_equal(se_dump_stack*caller,T83* C,T0* a1);
T6 r83all_default(se_dump_stack*caller,T83* C);
T0* r83twin(se_dump_stack*caller,T83* C);
extern se_frame_descriptor se_ifd83;
T83*se_i83(se_dump_stack*caller,T83*C);
void r80copy(se_dump_stack*caller,T80* C,T0* a1);
void r80clear_all(se_dump_stack*caller,T80* C);
T2 r80count(se_dump_stack*caller,T80* C);
void r80put(se_dump_stack*caller,T80* C,T6 a1,T2 a2);
T6 r80is_equal(se_dump_stack*caller,T80* C,T0* a1);
T6 r80item(se_dump_stack*caller,T80* C,T2 a1);
T6 r80valid_index(se_dump_stack*caller,T80* C,T2 a1);
void r80make(se_dump_stack*caller,T80* C,T2 a1,T2 a2);
void r80set_all_with(se_dump_stack*caller,T80* C,T6 a1);
T6 r80standard_is_equal(se_dump_stack*caller,T80* C,T0* a1);
T6 r80all_default(se_dump_stack*caller,T80* C);
T0* r80twin(se_dump_stack*caller,T80* C);
extern se_frame_descriptor se_ifd80;
T80*se_i80(se_dump_stack*caller,T80*C);
void r153copy(se_dump_stack*caller,T153* C,T0* a1);
void r153clear_all(se_dump_stack*caller,T153* C);
T2 r153count(se_dump_stack*caller,T153* C);
void r153put(se_dump_stack*caller,T153* C,T3 a1,T2 a2);
T6 r153is_equal(se_dump_stack*caller,T153* C,T0* a1);
T3 r153item(se_dump_stack*caller,T153* C,T2 a1);
T6 r153valid_index(se_dump_stack*caller,T153* C,T2 a1);
void r153make(se_dump_stack*caller,T153* C,T2 a1,T2 a2);
void r153set_all_with(se_dump_stack*caller,T153* C,T3 a1);
T6 r153standard_is_equal(se_dump_stack*caller,T153* C,T0* a1);
T6 r153all_default(se_dump_stack*caller,T153* C);
T0* r153twin(se_dump_stack*caller,T153* C);
extern se_frame_descriptor se_ifd153;
T153*se_i153(se_dump_stack*caller,T153*C);
void r64copy(se_dump_stack*caller,T64* C,T0* a1);
T0* r64last(se_dump_stack*caller,T64* C);
T2 r64count(se_dump_stack*caller,T64* C);
void r64put(se_dump_stack*caller,T64* C,T0* a1,T2 a2);
T6 r64is_equal(se_dump_stack*caller,T64* C,T0* a1);
T0* r64item(se_dump_stack*caller,T64* C,T2 a1);
T6 r64valid_index(se_dump_stack*caller,T64* C,T2 a1);
T6 r64is_empty(se_dump_stack*caller,T64* C);
T6 r64standard_is_equal(se_dump_stack*caller,T64* C,T0* a1);
void r64add_last(se_dump_stack*caller,T64* C,T0* a1);
void r64clear(se_dump_stack*caller,T64* C);
T0* r64twin(se_dump_stack*caller,T64* C);
void r64with_capacity(se_dump_stack*caller,T64* C,T2 a1,T2 a2);
extern se_frame_descriptor se_ifd64;
T64*se_i64(se_dump_stack*caller,T64*C);
void r47set_item(se_dump_stack*caller,T47* C,T0* a1);
T6 r47is_equal(se_dump_stack*caller,T47* C,T0* a1);
void r47make(se_dump_stack*caller,T47* C,T0* a1,T2 a2,T0* a3);
T6 r47standard_is_equal(se_dump_stack*caller,T47* C,T0* a1);
T0* r47twin(se_dump_stack*caller,T47* C);
void r47set_next(se_dump_stack*caller,T47* C,T0* a1);
void r75copy(se_dump_stack*caller,T75* C,T0* a1);
T2 r75column_maximum(se_dump_stack*caller,T75* C);
T6 r75valid_line(se_dump_stack*caller,T75* C,T2 a1);
T2 r75count(se_dump_stack*caller,T75* C);
void r75put(se_dump_stack*caller,T75* C,T0* a1,T2 a2,T2 a3);
T6 r75is_equal(se_dump_stack*caller,T75* C,T0* a1);
T2 r75column_minimum(se_dump_stack*caller,T75* C);
T0* r75item(se_dump_stack*caller,T75* C,T2 a1,T2 a2);
T6 r75valid_index(se_dump_stack*caller,T75* C,T2 a1,T2 a2);
T2 r75column_count(se_dump_stack*caller,T75* C);
void r75make(se_dump_stack*caller,T75* C,T2 a1,T2 a2,T2 a3,T2 a4);
T6 r75valid_index2(se_dump_stack*caller,T75* C,T2 a1);
T6 r75standard_is_equal(se_dump_stack*caller,T75* C,T0* a1);
T2 r75line_minimum(se_dump_stack*caller,T75* C);
T2 r75count1(se_dump_stack*caller,T75* C);
T2 r75count2(se_dump_stack*caller,T75* C);
T0* r75twin(se_dump_stack*caller,T75* C);
T2 r75line_maximum(se_dump_stack*caller,T75* C);
T2 r75line_count(se_dump_stack*caller,T75* C);
extern se_frame_descriptor se_ifd75;
T75*se_i75(se_dump_stack*caller,T75*C);
void r41next(se_dump_stack*caller,T41* C);
T6 r41is_equal(se_dump_stack*caller,T41* C,T0* a1);
T0* r41item(se_dump_stack*caller,T41* C);
void r41make(se_dump_stack*caller,T41* C,T0* a1);
T6 r41standard_is_equal(se_dump_stack*caller,T41* C,T0* a1);
T6 r41is_off(se_dump_stack*caller,T41* C);
void r41start(se_dump_stack*caller,T41* C);
T0* r41twin(se_dump_stack*caller,T41* C);
void r43set_item(se_dump_stack*caller,T43* C,T0* a1);
T6 r43is_equal(se_dump_stack*caller,T43* C,T0* a1);
void r43make(se_dump_stack*caller,T43* C,T0* a1,T0* a2);
T6 r43standard_is_equal(se_dump_stack*caller,T43* C,T0* a1);
T0* r43twin(se_dump_stack*caller,T43* C);
void r43set_next(se_dump_stack*caller,T43* C,T0* a1);
void r87set_item(se_dump_stack*caller,T87* C,T0* a1);
T6 r87is_equal(se_dump_stack*caller,T87* C,T0* a1);
void r87make(se_dump_stack*caller,T87* C,T0* a1,T0* a2);
T6 r87standard_is_equal(se_dump_stack*caller,T87* C,T0* a1);
T0* r87twin(se_dump_stack*caller,T87* C);
void r87set_next(se_dump_stack*caller,T87* C,T0* a1);
void r121set_item(se_dump_stack*caller,T121* C,T0* a1);
T6 r121is_equal(se_dump_stack*caller,T121* C,T0* a1);
void r121make(se_dump_stack*caller,T121* C,T0* a1,T0* a2);
T6 r121standard_is_equal(se_dump_stack*caller,T121* C,T0* a1);
T0* r121twin(se_dump_stack*caller,T121* C);
void r121set_next(se_dump_stack*caller,T121* C,T0* a1);
void r122next(se_dump_stack*caller,T122* C);
T6 r122is_equal(se_dump_stack*caller,T122* C,T0* a1);
T0* r122item(se_dump_stack*caller,T122* C);
void r122make(se_dump_stack*caller,T122* C,T0* a1);
T6 r122standard_is_equal(se_dump_stack*caller,T122* C,T0* a1);
T6 r122is_off(se_dump_stack*caller,T122* C);
void r122start(se_dump_stack*caller,T122* C);
T0* r122twin(se_dump_stack*caller,T122* C);
void r151next(se_dump_stack*caller,T151* C);
T6 r151is_equal(se_dump_stack*caller,T151* C,T0* a1);
T0* r151item(se_dump_stack*caller,T151* C);
void r151make(se_dump_stack*caller,T151* C,T0* a1);
T6 r151standard_is_equal(se_dump_stack*caller,T151* C,T0* a1);
T6 r151is_off(se_dump_stack*caller,T151* C);
void r151start(se_dump_stack*caller,T151* C);
T0* r151twin(se_dump_stack*caller,T151* C);
T6 r140is_equal(se_dump_stack*caller,T140* C,T0* a1);
T6 r140standard_is_equal(se_dump_stack*caller,T140* C,T0* a1);
T0* r140twin(se_dump_stack*caller,T140* C);
T6 r118safe_equal(se_dump_stack*caller,T118* C,T0* a1,T0* a2);
void r118copy(se_dump_stack*caller,T118* C,T0* a1);
T0* r118last(se_dump_stack*caller,T118* C);
T2 r118count(se_dump_stack*caller,T118* C);
T6 r118is_equal(se_dump_stack*caller,T118* C,T0* a1);
T0* r118item(se_dump_stack*caller,T118* C,T2 a1);
T6 r118valid_index(se_dump_stack*caller,T118* C,T2 a1);
T2 r118index_of(se_dump_stack*caller,T118* C,T0* a1);
void r118make(se_dump_stack*caller,T118* C);
T6 r118equal(se_dump_stack*caller,T118* C,T0* a1,T0* a2);
T6 r118is_empty(se_dump_stack*caller,T118* C);
T6 r118has(se_dump_stack*caller,T118* C,T0* a1);
T6 r118standard_is_equal(se_dump_stack*caller,T118* C,T0* a1);
T0* r118_px_64(se_dump_stack*caller,T118* C,T2 a1);
void r118add_last(se_dump_stack*caller,T118* C,T0* a1);
void r118clear(se_dump_stack*caller,T118* C);
T0* r118twin(se_dump_stack*caller,T118* C);
void r118go_item(se_dump_stack*caller,T118* C,T2 a1);
void r118from_collection(se_dump_stack*caller,T118* C,T0* a1);
extern se_frame_descriptor se_ifd118;
T118*se_i118(se_dump_stack*caller,T118*C);
void r105copy(se_dump_stack*caller,T105* C,T0* a1);
T0* r105last(se_dump_stack*caller,T105* C);
T2 r105count(se_dump_stack*caller,T105* C);
T6 r105is_equal(se_dump_stack*caller,T105* C,T0* a1);
T0* r105item(se_dump_stack*caller,T105* C,T2 a1);
T6 r105valid_index(se_dump_stack*caller,T105* C,T2 a1);
void r105make(se_dump_stack*caller,T105* C);
T6 r105is_empty(se_dump_stack*caller,T105* C);
T0* r105get_new_iterator(se_dump_stack*caller,T105* C);
T6 r105standard_is_equal(se_dump_stack*caller,T105* C,T0* a1);
void r105add_last(se_dump_stack*caller,T105* C,T0* a1);
void r105clear(se_dump_stack*caller,T105* C);
T0* r105twin(se_dump_stack*caller,T105* C);
void r105go_item(se_dump_stack*caller,T105* C,T2 a1);
void r105from_collection(se_dump_stack*caller,T105* C,T0* a1);
extern se_frame_descriptor se_ifd105;
T105*se_i105(se_dump_stack*caller,T105*C);
void r45copy(se_dump_stack*caller,T45* C,T0* a1);
T2 r45key(se_dump_stack*caller,T45* C,T2 a1);
T0* r45at(se_dump_stack*caller,T45* C,T2 a1);
T2 r45upper(se_dump_stack*caller,T45* C);
void r45put(se_dump_stack*caller,T45* C,T0* a1,T2 a2);
T6 r45is_equal(se_dump_stack*caller,T45* C,T0* a1);
T0* r45item(se_dump_stack*caller,T45* C,T2 a1);
T6 r45valid_index(se_dump_stack*caller,T45* C,T2 a1);
void r45set_cache_user(se_dump_stack*caller,T45* C,T2 a1);
void r45make(se_dump_stack*caller,T45* C);
T6 r45is_empty(se_dump_stack*caller,T45* C);
void r45increase_capacity(se_dump_stack*caller,T45* C);
T6 r45standard_is_equal(se_dump_stack*caller,T45* C,T0* a1);
T6 r45has(se_dump_stack*caller,T45* C,T2 a1);
void r45clear(se_dump_stack*caller,T45* C);
T0* r45twin(se_dump_stack*caller,T45* C);
void r45with_capacity(se_dump_stack*caller,T45* C,T2 a1);
extern se_frame_descriptor se_ifd45;
T45*se_i45(se_dump_stack*caller,T45*C);
void r39copy(se_dump_stack*caller,T39* C,T0* a1);
void r39do_all(se_dump_stack*caller,T39* C,/*agent*/T0* a1);
T0* r39last(se_dump_stack*caller,T39* C);
T2 r39count(se_dump_stack*caller,T39* C);
T6 r39is_equal(se_dump_stack*caller,T39* C,T0* a1);
T0* r39item(se_dump_stack*caller,T39* C,T2 a1);
T6 r39valid_index(se_dump_stack*caller,T39* C,T2 a1);
void r39make(se_dump_stack*caller,T39* C);
T6 r39is_empty(se_dump_stack*caller,T39* C);
T0* r39get_new_iterator(se_dump_stack*caller,T39* C);
T6 r39standard_is_equal(se_dump_stack*caller,T39* C,T0* a1);
void r39add_last(se_dump_stack*caller,T39* C,T0* a1);
void r39clear(se_dump_stack*caller,T39* C);
T0* r39twin(se_dump_stack*caller,T39* C);
void r39go_item(se_dump_stack*caller,T39* C,T2 a1);
void r39from_collection(se_dump_stack*caller,T39* C,T0* a1);
extern se_frame_descriptor se_ifd39;
T39*se_i39(se_dump_stack*caller,T39*C);
void r131copy(se_dump_stack*caller,T131* C,T0* a1);
void r131do_all(se_dump_stack*caller,T131* C,/*agent*/T0* a1);
T0* r131key(se_dump_stack*caller,T131* C,T2 a1);
T0* r131at(se_dump_stack*caller,T131* C,T0* a1);
T2 r131upper(se_dump_stack*caller,T131* C);
void r131put(se_dump_stack*caller,T131* C,T0* a1,T0* a2);
T6 r131is_equal(se_dump_stack*caller,T131* C,T0* a1);
T0* r131item(se_dump_stack*caller,T131* C,T2 a1);
T6 r131valid_index(se_dump_stack*caller,T131* C,T2 a1);
void r131set_cache_user(se_dump_stack*caller,T131* C,T2 a1);
void r131make(se_dump_stack*caller,T131* C);
T6 r131is_empty(se_dump_stack*caller,T131* C);
void r131increase_capacity(se_dump_stack*caller,T131* C);
T6 r131standard_is_equal(se_dump_stack*caller,T131* C,T0* a1);
T6 r131has(se_dump_stack*caller,T131* C,T0* a1);
void r131clear(se_dump_stack*caller,T131* C);
T0* r131twin(se_dump_stack*caller,T131* C);
void r131with_capacity(se_dump_stack*caller,T131* C,T2 a1);
extern se_frame_descriptor se_ifd131;
T131*se_i131(se_dump_stack*caller,T131*C);
void r67set_item(se_dump_stack*caller,T67* C,T0* a1);
T6 r67is_equal(se_dump_stack*caller,T67* C,T0* a1);
void r67make(se_dump_stack*caller,T67* C,T0* a1,T0* a2);
T6 r67standard_is_equal(se_dump_stack*caller,T67* C,T0* a1);
T0* r67twin(se_dump_stack*caller,T67* C);
void r67set_next(se_dump_stack*caller,T67* C,T0* a1);
void r86copy(se_dump_stack*caller,T86* C,T0* a1);
T0* r86last(se_dump_stack*caller,T86* C);
void r86remove_first(se_dump_stack*caller,T86* C);
T2 r86count(se_dump_stack*caller,T86* C);
T6 r86is_equal(se_dump_stack*caller,T86* C,T0* a1);
T0* r86item(se_dump_stack*caller,T86* C,T2 a1);
T6 r86valid_index(se_dump_stack*caller,T86* C,T2 a1);
void r86make(se_dump_stack*caller,T86* C);
void r86remove(se_dump_stack*caller,T86* C,T2 a1);
T6 r86is_empty(se_dump_stack*caller,T86* C);
void r86remove_last(se_dump_stack*caller,T86* C);
T6 r86standard_is_equal(se_dump_stack*caller,T86* C,T0* a1);
T0* r86_px_64(se_dump_stack*caller,T86* C,T2 a1);
void r86add_last(se_dump_stack*caller,T86* C,T0* a1);
T0* r86first(se_dump_stack*caller,T86* C);
void r86clear(se_dump_stack*caller,T86* C);
T0* r86twin(se_dump_stack*caller,T86* C);
void r86go_item(se_dump_stack*caller,T86* C,T2 a1);
void r86from_collection(se_dump_stack*caller,T86* C,T0* a1);
extern se_frame_descriptor se_ifd86;
T86*se_i86(se_dump_stack*caller,T86*C);
void r106set_item(se_dump_stack*caller,T106* C,T0* a1);
T6 r106is_equal(se_dump_stack*caller,T106* C,T0* a1);
void r106make(se_dump_stack*caller,T106* C,T0* a1,T0* a2);
T6 r106standard_is_equal(se_dump_stack*caller,T106* C,T0* a1);
T0* r106twin(se_dump_stack*caller,T106* C);
void r106set_next(se_dump_stack*caller,T106* C,T0* a1);
void r66copy(se_dump_stack*caller,T66* C,T0* a1);
void r66do_all(se_dump_stack*caller,T66* C,/*agent*/T0* a1);
T0* r66last(se_dump_stack*caller,T66* C);
T2 r66count(se_dump_stack*caller,T66* C);
T6 r66is_equal(se_dump_stack*caller,T66* C,T0* a1);
T0* r66item(se_dump_stack*caller,T66* C,T2 a1);
T6 r66valid_index(se_dump_stack*caller,T66* C,T2 a1);
void r66make(se_dump_stack*caller,T66* C);
T6 r66is_empty(se_dump_stack*caller,T66* C);
T0* r66get_new_iterator(se_dump_stack*caller,T66* C);
T6 r66standard_is_equal(se_dump_stack*caller,T66* C,T0* a1);
void r66add_last(se_dump_stack*caller,T66* C,T0* a1);
void r66clear(se_dump_stack*caller,T66* C);
T0* r66twin(se_dump_stack*caller,T66* C);
void r66go_item(se_dump_stack*caller,T66* C,T2 a1);
void r66from_collection(se_dump_stack*caller,T66* C,T0* a1);
extern se_frame_descriptor se_ifd66;
T66*se_i66(se_dump_stack*caller,T66*C);
void r132set_item(se_dump_stack*caller,T132* C,T0* a1);
T6 r132is_equal(se_dump_stack*caller,T132* C,T0* a1);
void r132make(se_dump_stack*caller,T132* C,T0* a1,T0* a2,T0* a3);
T6 r132standard_is_equal(se_dump_stack*caller,T132* C,T0* a1);
T0* r132twin(se_dump_stack*caller,T132* C);
void r132set_next(se_dump_stack*caller,T132* C,T0* a1);
/* Extra external prototype for line 113 of ./image.e:*/
T8 free_img(T8 a1);
T8 r50free_img(se_dump_stack*caller,T8 a1);
void r50convert_display_format(se_dump_stack*caller,T50* C);
void r50render_string(se_dump_stack*caller,T50* C,T0* a1,T0* a2,T0* a3);
T6 r50is_equal(se_dump_stack*caller,T50* C,T0* a1);
/* Extra external prototype for line 145 of ./image.e:*/
T8 ext_display_format(T8 a1);
T8 r50ext_display_format(se_dump_stack*caller,T8 a1);
/* Extra external prototype for line 117 of ./image.e:*/
T8 ext_render_text(T8 a1,T8 a2,T8 a3);
T8 r50ext_render_text(se_dump_stack*caller,T8 a1,T8 a2,T8 a3);
extern T0*oBC1io;
void r50make(se_dump_stack*caller,T50* C);
/* Extra external prototype for line 137 of ./image.e:*/
void blit_img(T8 a1,T2 a2,T2 a3);
void r50blit_img(se_dump_stack*caller,T8 a1,T2 a2,T2 a3);
void r50new_dummy(se_dump_stack*caller,T50* C);
T6 r50standard_is_equal(se_dump_stack*caller,T50* C,T0* a1);
/* Extra external prototype for line 149 of ./image.e:*/
T8 ext_new_dummy(void);
T8 r50ext_new_dummy(se_dump_stack*caller);
void r50blit(se_dump_stack*caller,T50* C,T2 a1,T2 a2);
T0* r50twin(se_dump_stack*caller,T50* C);
void r50free(se_dump_stack*caller,T50* C);
T6 r114is_equal(se_dump_stack*caller,T114* C,T0* a1);
void r114make(se_dump_stack*caller,T114* C,T0* a1);
T6 r114standard_is_equal(se_dump_stack*caller,T114* C,T0* a1);
void r114execute(se_dump_stack*caller,T114* C);
T0* r114twin(se_dump_stack*caller,T114* C);
T6 r135is_equal(se_dump_stack*caller,T135* C,T0* a1);
void r135make(se_dump_stack*caller,T135* C,T0* a1);
T6 r135standard_is_equal(se_dump_stack*caller,T135* C,T0* a1);
void r135execute(se_dump_stack*caller,T135* C);
T0* r135twin(se_dump_stack*caller,T135* C);
void r130parse_scores(se_dump_stack*caller,T130* C);
void r130into_preset_list(se_dump_stack*caller,T130* C,T0* a1);
void r130import_score(se_dump_stack*caller,T130* C,T0* a1);
T6 r130is_equal(se_dump_stack*caller,T130* C,T0* a1);
void r130load(se_dump_stack*caller,T130* C,T0* a1);
void r130make(se_dump_stack*caller,T130* C);
void r130from_preset_list(se_dump_stack*caller,T130* C,T0* a1);
void r130export_score(se_dump_stack*caller,T130* C,T0* a1);
T6 r130standard_is_equal(se_dump_stack*caller,T130* C,T0* a1);
void r130save(se_dump_stack*caller,T130* C,T0* a1);
T0* r130twin(se_dump_stack*caller,T130* C);
void r130write_score(se_dump_stack*caller,T130* C,T0* a1,T0* a2);
void r117put_command(se_dump_stack*caller,T117* C,T0* a1,T2 a2);
void r117move_widget(se_dump_stack*caller,T117* C,T0* a1,T2 a2,T2 a3);
void r117change_focus(se_dump_stack*caller,T117* C,T0* a1);
void r117_30Pwidget_init(se_dump_stack*caller,T117* C);
T6 r117is_equal(se_dump_stack*caller,T117* C,T0* a1);
void r117_30Pput_xy(se_dump_stack*caller,T117* C,T2 a1,T2 a2);
void r117preset_change(se_dump_stack*caller,T117* C);
void r117add_widget(se_dump_stack*caller,T117* C,T0* a1,T2 a2,T2 a3);
void r117put_info(se_dump_stack*caller,T117* C,T0* a1,T0* a2);
void r117widget_init(se_dump_stack*caller,T117* C);
void r117put_preset_list(se_dump_stack*caller,T117* C,T0* a1);
void r117make(se_dump_stack*caller,T117* C);
T6 r117contains(se_dump_stack*caller,T117* C,T2 a1,T2 a2);
void r117fill_rect(se_dump_stack*caller,T117* C,T2 a1,T2 a2,T2 a3,T2 a4,T0* a5);
void r117put_xy(se_dump_stack*caller,T117* C,T2 a1,T2 a2);
T6 r117standard_is_equal(se_dump_stack*caller,T117* C,T0* a1);
void r117put_size(se_dump_stack*caller,T117* C,T2 a1,T2 a2);
/* Extra external prototype for line 95 of ./widget.e:*/
void ext_fill_rect(T2 a1,T2 a2,T2 a3,T2 a4,T2 a5);
void r117ext_fill_rect(se_dump_stack*caller,T2 a1,T2 a2,T2 a3,T2 a4,T2 a5);
void r117custom_change(se_dump_stack*caller,T117* C);
extern T0*oBC18green;
extern int fBC18green;
T0* r117green(se_dump_stack*caller);
void r117put_focus(se_dump_stack*caller,T117* C,T6 a1);
void r117process_event(se_dump_stack*caller,T117* C,T0* a1);
extern T0*oBC117custom;
extern int fBC117custom;
T0* r117custom(se_dump_stack*caller);
void r117update_setting(se_dump_stack*caller,T117* C);
T0* r117twin(se_dump_stack*caller,T117* C);
T0* r117get_preset(se_dump_stack*caller,T117* C,T0* a1);
void r117raise_signal(se_dump_stack*caller,T117* C,T2 a1);
void r117update(se_dump_stack*caller,T117* C);
extern T0*oBC18black;
extern int fBC18black;
T0* r117black(se_dump_stack*caller);
void r126put_command(se_dump_stack*caller,T126* C,T0* a1,T2 a2);
T6 r126is_equal(se_dump_stack*caller,T126* C,T0* a1);
void r126widget_init(se_dump_stack*caller,T126* C);
void r126make(se_dump_stack*caller,T126* C);
T6 r126contains(se_dump_stack*caller,T126* C,T2 a1,T2 a2);
void r126fill_rect(se_dump_stack*caller,T126* C,T2 a1,T2 a2,T2 a3,T2 a4,T0* a5);
void r126put_xy(se_dump_stack*caller,T126* C,T2 a1,T2 a2);
T6 r126standard_is_equal(se_dump_stack*caller,T126* C,T0* a1);
void r126put_value(se_dump_stack*caller,T126* C,T6 a1);
void r126put_size(se_dump_stack*caller,T126* C,T2 a1,T2 a2);
/* Extra external prototype for line 95 of ./widget.e:*/
void ext_fill_rect(T2 a1,T2 a2,T2 a3,T2 a4,T2 a5);
void r126ext_fill_rect(se_dump_stack*caller,T2 a1,T2 a2,T2 a3,T2 a4,T2 a5);
T0* r126green(se_dump_stack*caller);
extern T0*oBC18darkgreen;
extern int fBC18darkgreen;
T0* r126darkgreen(se_dump_stack*caller);
void r126put_focus(se_dump_stack*caller,T126* C,T6 a1);
void r126process_event(se_dump_stack*caller,T126* C,T0* a1);
T0* r126twin(se_dump_stack*caller,T126* C);
extern T0*oBC18white;
extern int fBC18white;
T0* r126white(se_dump_stack*caller);
void r126raise_signal(se_dump_stack*caller,T126* C,T2 a1);
void r126update(se_dump_stack*caller,T126* C);
T6 r54is_equal(se_dump_stack*caller,T54* C,T0* a1);
void r54read_config(se_dump_stack*caller,T54* C,T0* a1);
T0* r54clone(se_dump_stack*caller,T54* C,T0* a1);
void r54parse_preset(se_dump_stack*caller,T54* C,T0* a1,T0* a2);
void r54make(se_dump_stack*caller,T54* C);
T6 r54equal(se_dump_stack*caller,T54* C,T0* a1,T0* a2);
T6 r54standard_is_equal(se_dump_stack*caller,T54* C,T0* a1);
T0* r54twin(se_dump_stack*caller,T54* C);
T0* r54get_preset(se_dump_stack*caller,T54* C,T0* a1);
void r54load_config(se_dump_stack*caller,T54* C);
extern T0*oBC17config;
extern int fBC17config;
T0* r107config(se_dump_stack*caller);
T6 r107is_equal(se_dump_stack*caller,T107* C,T0* a1);
void r107widget_init(se_dump_stack*caller,T107* C);
void r107update_image(se_dump_stack*caller,T107* C);
void r107make(se_dump_stack*caller,T107* C,T0* a1);
T6 r107contains(se_dump_stack*caller,T107* C,T2 a1,T2 a2);
void r107fill_rect(se_dump_stack*caller,T107* C,T2 a1,T2 a2,T2 a3,T2 a4,T0* a5);
void r107put_xy(se_dump_stack*caller,T107* C,T2 a1,T2 a2);
T6 r107standard_is_equal(se_dump_stack*caller,T107* C,T0* a1);
void r107put_size(se_dump_stack*caller,T107* C,T2 a1,T2 a2);
/* Extra external prototype for line 95 of ./widget.e:*/
void ext_fill_rect(T2 a1,T2 a2,T2 a3,T2 a4,T2 a5);
void r107ext_fill_rect(se_dump_stack*caller,T2 a1,T2 a2,T2 a3,T2 a4,T2 a5);
void r107put_focus(se_dump_stack*caller,T107* C,T6 a1);
void r107blit(se_dump_stack*caller,T107* C,T0* a1,T2 a2,T2 a3);
void r107process_event(se_dump_stack*caller,T107* C,T0* a1);
T0* r107twin(se_dump_stack*caller,T107* C);
T0* r107white(se_dump_stack*caller);
void r107raise_signal(se_dump_stack*caller,T107* C,T2 a1);
T0* r107font(se_dump_stack*caller,T107* C);
void r107put_string(se_dump_stack*caller,T107* C,T0* a1);
void r107update(se_dump_stack*caller,T107* C);
T0* r107black(se_dump_stack*caller);
void r120put_command(se_dump_stack*caller,T120* C,T0* a1,T2 a2);
void r120next_string(se_dump_stack*caller,T120* C);
T0* r120config(se_dump_stack*caller);
T6 r120is_equal(se_dump_stack*caller,T120* C,T0* a1);
void r120prev_string(se_dump_stack*caller,T120* C);
void r120widget_init(se_dump_stack*caller,T120* C);
void r120update_image(se_dump_stack*caller,T120* C);
void r120make(se_dump_stack*caller,T120* C);
T6 r120contains(se_dump_stack*caller,T120* C,T2 a1,T2 a2);
void r120fill_rect(se_dump_stack*caller,T120* C,T2 a1,T2 a2,T2 a3,T2 a4,T0* a5);
void r120put_xy(se_dump_stack*caller,T120* C,T2 a1,T2 a2);
T6 r120standard_is_equal(se_dump_stack*caller,T120* C,T0* a1);
void r120put_size(se_dump_stack*caller,T120* C,T2 a1,T2 a2);
/* Extra external prototype for line 95 of ./widget.e:*/
void ext_fill_rect(T2 a1,T2 a2,T2 a3,T2 a4,T2 a5);
void r120ext_fill_rect(se_dump_stack*caller,T2 a1,T2 a2,T2 a3,T2 a4,T2 a5);
extern T0*oBC18grey;
extern int fBC18grey;
T0* r120grey(se_dump_stack*caller);
void r120put_focus(se_dump_stack*caller,T120* C,T6 a1);
void r120blit(se_dump_stack*caller,T120* C,T0* a1,T2 a2,T2 a3);
void r120process_event(se_dump_stack*caller,T120* C,T0* a1);
T0* r120twin(se_dump_stack*caller,T120* C);
T0* r120white(se_dump_stack*caller);
void r120raise_signal(se_dump_stack*caller,T120* C,T2 a1);
T0* r120font(se_dump_stack*caller,T120* C);
void r120put_list(se_dump_stack*caller,T120* C,T0* a1);
void r120put_string(se_dump_stack*caller,T120* C,T0* a1);
void r120update(se_dump_stack*caller,T120* C);
T0* r120black(se_dump_stack*caller);
T6 r53is_equal(se_dump_stack*caller,T53* C,T0* a1);
void r53load(se_dump_stack*caller,T53* C,T0* a1,T2 a2);
T6 r53standard_is_equal(se_dump_stack*caller,T53* C,T0* a1);
/* Extra external prototype for line 52 of ./ttf_font.e:*/
T8 ext_ttf_openfont(T8 a1,T2 a2);
T8 r53ext_ttf_openfont(se_dump_stack*caller,T8 a1,T2 a2);
T8 r53to_external(se_dump_stack*caller,T53* C);
T0* r53twin(se_dump_stack*caller,T53* C);
void r77next(se_dump_stack*caller,T77* C);
T2 r77last_integer(se_dump_stack*caller,T77* C,T2 a1);
T6 r77is_equal(se_dump_stack*caller,T77* C,T0* a1);
void r77with_seed(se_dump_stack*caller,T77* C,T2 a1);
T6 r77standard_is_equal(se_dump_stack*caller,T77* C,T0* a1);
void r77min_next(se_dump_stack*caller,T77* C);
T0* r77twin(se_dump_stack*caller,T77* C);
extern se_frame_descriptor se_ifd77;
T77*se_i77(se_dump_stack*caller,T77*C);
/* Extra external prototype for line 28 of ./color.e:*/
T8 ext_make_color(T2 a1,T2 a2,T2 a3);
T8 r51ext_make_color(se_dump_stack*caller,T2 a1,T2 a2,T2 a3);
/* Extra external prototype for line 36 of ./color.e:*/
T2 ext_convert_color(T2 a1,T2 a2,T2 a3);
T2 r51ext_convert_color(se_dump_stack*caller,T2 a1,T2 a2,T2 a3);
T6 r51is_equal(se_dump_stack*caller,T51* C,T0* a1);
void r51make(se_dump_stack*caller,T51* C,T2 a1,T2 a2,T2 a3);
T6 r51standard_is_equal(se_dump_stack*caller,T51* C,T0* a1);
T8 r51to_external(se_dump_stack*caller,T51* C);
T0* r51twin(se_dump_stack*caller,T51* C);
void r97put_command(se_dump_stack*caller,T97* C,T0* a1,T2 a2);
void r97move_widget(se_dump_stack*caller,T97* C,T0* a1,T2 a2,T2 a3);
void r97change_focus(se_dump_stack*caller,T97* C,T0* a1);
void r97_30Pwidget_init(se_dump_stack*caller,T97* C);
T6 r97is_equal(se_dump_stack*caller,T97* C,T0* a1);
void r97_30Pput_xy(se_dump_stack*caller,T97* C,T2 a1,T2 a2);
void r97add_widget(se_dump_stack*caller,T97* C,T0* a1,T2 a2,T2 a3);
void r97widget_init(se_dump_stack*caller,T97* C);
void r97make(se_dump_stack*caller,T97* C);
T6 r97contains(se_dump_stack*caller,T97* C,T2 a1,T2 a2);
void r97fill_rect(se_dump_stack*caller,T97* C,T2 a1,T2 a2,T2 a3,T2 a4,T0* a5);
void r97put_xy(se_dump_stack*caller,T97* C,T2 a1,T2 a2);
T6 r97standard_is_equal(se_dump_stack*caller,T97* C,T0* a1);
void r97put_size(se_dump_stack*caller,T97* C,T2 a1,T2 a2);
/* Extra external prototype for line 95 of ./widget.e:*/
void ext_fill_rect(T2 a1,T2 a2,T2 a3,T2 a4,T2 a5);
void r97ext_fill_rect(se_dump_stack*caller,T2 a1,T2 a2,T2 a3,T2 a4,T2 a5);
T0* r97green(se_dump_stack*caller);
void r97put_focus(se_dump_stack*caller,T97* C,T6 a1);
void r97process_event(se_dump_stack*caller,T97* C,T0* a1);
T0* r97twin(se_dump_stack*caller,T97* C);
void r97raise_signal(se_dump_stack*caller,T97* C,T2 a1);
void r97update(se_dump_stack*caller,T97* C);
T0* r97black(se_dump_stack*caller);
void r99put_command(se_dump_stack*caller,T99* C,T0* a1,T2 a2);
void r99move_widget(se_dump_stack*caller,T99* C,T0* a1,T2 a2,T2 a3);
void r99change_focus(se_dump_stack*caller,T99* C,T0* a1);
void r99_30Pwidget_init(se_dump_stack*caller,T99* C);
T6 r99is_equal(se_dump_stack*caller,T99* C,T0* a1);
void r99_30Pput_xy(se_dump_stack*caller,T99* C,T2 a1,T2 a2);
void r99add_new_score(se_dump_stack*caller,T99* C,T0* a1);
void r99add_widget(se_dump_stack*caller,T99* C,T0* a1,T2 a2,T2 a3);
void r99widget_init(se_dump_stack*caller,T99* C);
void r99update_score(se_dump_stack*caller,T99* C,T0* a1);
void r99make(se_dump_stack*caller,T99* C);
T6 r99contains(se_dump_stack*caller,T99* C,T2 a1,T2 a2);
void r99fill_rect(se_dump_stack*caller,T99* C,T2 a1,T2 a2,T2 a3,T2 a4,T0* a5);
void r99put_xy(se_dump_stack*caller,T99* C,T2 a1,T2 a2);
void r99init_scores(se_dump_stack*caller,T99* C,T0* a1);
T6 r99standard_is_equal(se_dump_stack*caller,T99* C,T0* a1);
void r99put_size(se_dump_stack*caller,T99* C,T2 a1,T2 a2);
/* Extra external prototype for line 95 of ./widget.e:*/
void ext_fill_rect(T2 a1,T2 a2,T2 a3,T2 a4,T2 a5);
void r99ext_fill_rect(se_dump_stack*caller,T2 a1,T2 a2,T2 a3,T2 a4,T2 a5);
T0* r99green(se_dump_stack*caller);
void r99put_focus(se_dump_stack*caller,T99* C,T6 a1);
void r99process_event(se_dump_stack*caller,T99* C,T0* a1);
T0* r99twin(se_dump_stack*caller,T99* C);
void r99raise_signal(se_dump_stack*caller,T99* C,T2 a1);
void r99update(se_dump_stack*caller,T99* C);
T0* r99black(se_dump_stack*caller);
void r113put_command(se_dump_stack*caller,T113* C,T0* a1,T2 a2);
T0* r113config(se_dump_stack*caller);
T6 r113is_equal(se_dump_stack*caller,T113* C,T0* a1);
void r113widget_init(se_dump_stack*caller,T113* C);
void r113update_image(se_dump_stack*caller,T113* C);
void r113make(se_dump_stack*caller,T113* C,T0* a1);
T6 r113contains(se_dump_stack*caller,T113* C,T2 a1,T2 a2);
void r113fill_rect(se_dump_stack*caller,T113* C,T2 a1,T2 a2,T2 a3,T2 a4,T0* a5);
void r113put_xy(se_dump_stack*caller,T113* C,T2 a1,T2 a2);
T6 r113standard_is_equal(se_dump_stack*caller,T113* C,T0* a1);
void r113put_size(se_dump_stack*caller,T113* C,T2 a1,T2 a2);
/* Extra external prototype for line 95 of ./widget.e:*/
void ext_fill_rect(T2 a1,T2 a2,T2 a3,T2 a4,T2 a5);
void r113ext_fill_rect(se_dump_stack*caller,T2 a1,T2 a2,T2 a3,T2 a4,T2 a5);
T0* r113darkgreen(se_dump_stack*caller);
void r113put_focus(se_dump_stack*caller,T113* C,T6 a1);
void r113blit(se_dump_stack*caller,T113* C,T0* a1,T2 a2,T2 a3);
void r113process_event(se_dump_stack*caller,T113* C,T0* a1);
T0* r113twin(se_dump_stack*caller,T113* C);
T0* r113white(se_dump_stack*caller);
void r113raise_signal(se_dump_stack*caller,T113* C,T2 a1);
T0* r113font(se_dump_stack*caller,T113* C);
void r113update(se_dump_stack*caller,T113* C);
T0* r113black(se_dump_stack*caller);
void r55disconnect(se_dump_stack*caller,T55* C);
T6 r55is_equal(se_dump_stack*caller,T55* C,T0* a1);
T6 r55is_connected(se_dump_stack*caller,T55* C);
void r55read_character(se_dump_stack*caller,T55* C);
void r55skip_separators(se_dump_stack*caller,T55* C);
void r55read_line_in(se_dump_stack*caller,T55* C,T0* a1);
T6 r55standard_is_equal(se_dump_stack*caller,T55* C,T0* a1);
T6 r55end_of_input(se_dump_stack*caller,T55* C);
void r55connect_to(se_dump_stack*caller,T55* C,T0* a1);
void r55read_line(se_dump_stack*caller,T55* C);
T3 r55last_character(se_dump_stack*caller,T55* C);
void r55read_word(se_dump_stack*caller,T55* C);
T0* r55twin(se_dump_stack*caller,T55* C);
extern T0*oBC56last_string;
extern int fBC56last_string;
T0* r55last_string(se_dump_stack*caller);
void r55unread_character(se_dump_stack*caller,T55* C);
T6 r65is_equal(se_dump_stack*caller,T65* C,T0* a1);
void r65make(se_dump_stack*caller,T65* C,T0* a1,T2 a2,T2 a3,T6 a4);
void r65put_hiscore(se_dump_stack*caller,T65* C,T0* a1);
T6 r65standard_is_equal(se_dump_stack*caller,T65* C,T0* a1);
T0* r65twin(se_dump_stack*caller,T65* C);
T6 r128is_equal(se_dump_stack*caller,T128* C,T0* a1);
void r128make(se_dump_stack*caller,T128* C,T0* a1);
T6 r128standard_is_equal(se_dump_stack*caller,T128* C,T0* a1);
void r128execute(se_dump_stack*caller,T128* C);
T0* r128twin(se_dump_stack*caller,T128* C);
void r68copy(se_dump_stack*caller,T68* C,T0* a1);
void r68put_height(se_dump_stack*caller,T68* C,T2 a1);
T6 r68is_equal(se_dump_stack*caller,T68* C,T0* a1);
T2 r68clip_height(se_dump_stack*caller,T68* C,T2 a1);
void r68make(se_dump_stack*caller,T68* C);
T6 r68standard_is_equal(se_dump_stack*caller,T68* C,T0* a1);
void r68put_wrap(se_dump_stack*caller,T68* C,T6 a1);
T2 r68clip_width(se_dump_stack*caller,T68* C,T2 a1);
T0* r68twin(se_dump_stack*caller,T68* C);
void r68put_width(se_dump_stack*caller,T68* C,T2 a1);
T6 r129is_equal(se_dump_stack*caller,T129* C,T0* a1);
void r129make(se_dump_stack*caller,T129* C,T0* a1);
T6 r129standard_is_equal(se_dump_stack*caller,T129* C,T0* a1);
void r129execute(se_dump_stack*caller,T129* C);
T0* r129twin(se_dump_stack*caller,T129* C);
T6 r96is_equal(se_dump_stack*caller,T96* C,T0* a1);
void r96make(se_dump_stack*caller,T96* C,T0* a1,T2 a2,T2 a3);
T6 r96standard_is_equal(se_dump_stack*caller,T96* C,T0* a1);
T0* r96twin(se_dump_stack*caller,T96* C);
void r96put_name(se_dump_stack*caller,T96* C,T0* a1);
T6 r127is_equal(se_dump_stack*caller,T127* C,T0* a1);
void r127make(se_dump_stack*caller,T127* C,T0* a1);
T6 r127standard_is_equal(se_dump_stack*caller,T127* C,T0* a1);
void r127execute(se_dump_stack*caller,T127* C);
T0* r127twin(se_dump_stack*caller,T127* C);
void r98put_command(se_dump_stack*caller,T98* C,T0* a1,T2 a2);
void r98process_key(se_dump_stack*caller,T98* C,T0* a1);
T0* r98config(se_dump_stack*caller);
/* Extra external prototype for line 272 of ./sdl_constant.e:*/
T6 is_kmod(T2 a1,T2 a2);
T6 r98is_kmod(se_dump_stack*caller,T2 a1,T2 a2);
T6 r98is_equal(se_dump_stack*caller,T98* C,T0* a1);
T6 r98is_normal_key(se_dump_stack*caller,T98* C,T2 a1);
void r98text_backspace(se_dump_stack*caller,T98* C);
void r98widget_init(se_dump_stack*caller,T98* C);
void r98update_image(se_dump_stack*caller,T98* C);
void r98make(se_dump_stack*caller,T98* C);
T6 r98contains(se_dump_stack*caller,T98* C,T2 a1,T2 a2);
void r98fill_rect(se_dump_stack*caller,T98* C,T2 a1,T2 a2,T2 a3,T2 a4,T0* a5);
void r98put_xy(se_dump_stack*caller,T98* C,T2 a1,T2 a2);
/* Extra external prototype for line 147 of ./widget.e:*/
T2 ext_get_tsh(void);
T2 r98ext_get_tsh(se_dump_stack*caller);
T6 r98standard_is_equal(se_dump_stack*caller,T98* C,T0* a1);
void r98put_size(se_dump_stack*caller,T98* C,T2 a1,T2 a2);
/* Extra external prototype for line 95 of ./widget.e:*/
void ext_fill_rect(T2 a1,T2 a2,T2 a3,T2 a4,T2 a5);
void r98ext_fill_rect(se_dump_stack*caller,T2 a1,T2 a2,T2 a3,T2 a4,T2 a5);
void r98text_insert(se_dump_stack*caller,T98* C,T3 a1);
/* Extra external prototype for line 143 of ./widget.e:*/
T2 ext_get_tsw(void);
T2 r98ext_get_tsw(se_dump_stack*caller);
T0* r98grey(se_dump_stack*caller);
void r98put_focus(se_dump_stack*caller,T98* C,T6 a1);
void r98blit(se_dump_stack*caller,T98* C,T0* a1,T2 a2,T2 a3);
void r98process_event(se_dump_stack*caller,T98* C,T0* a1);
/* Extra external prototype for line 139 of ./widget.e:*/
void ext_get_text_size(T8 a1,T8 a2);
void r98ext_get_text_size(se_dump_stack*caller,T8 a1,T8 a2);
T0* r98twin(se_dump_stack*caller,T98* C);
T0* r98white(se_dump_stack*caller);
extern T0*oBC98shifted_key_table;
extern int fBC98shifted_key_table;
T0* r98shifted_key_table(se_dump_stack*caller);
void r98raise_signal(se_dump_stack*caller,T98* C,T2 a1);
T0* r98font(se_dump_stack*caller,T98* C);
T3 r98shifted_key(se_dump_stack*caller,T98* C,T2 a1);
void r98measure_text_size(se_dump_stack*caller,T98* C,T0* a1);
void r98text_delete(se_dump_stack*caller,T98* C);
void r98put_string(se_dump_stack*caller,T98* C,T0* a1);
void r98update(se_dump_stack*caller,T98* C);
T0* r98black(se_dump_stack*caller);
T6 r104is_equal(se_dump_stack*caller,T104* C,T0* a1);
void r104make(se_dump_stack*caller,T104* C,T0* a1,T0* a2);
T6 r104standard_is_equal(se_dump_stack*caller,T104* C,T0* a1);
T0* r104twin(se_dump_stack*caller,T104* C);
void r28put_type(se_dump_stack*caller,T28* C,T2 a1);
T6 r28is_equal(se_dump_stack*caller,T28* C,T0* a1);
void r28make(se_dump_stack*caller,T28* C);
void r28put_xy(se_dump_stack*caller,T28* C,T2 a1,T2 a2);
T6 r28standard_is_equal(se_dump_stack*caller,T28* C,T0* a1);
void r28put_kmod(se_dump_stack*caller,T28* C,T2 a1);
void r28put_i1(se_dump_stack*caller,T28* C,T2 a1);
T0* r28twin(se_dump_stack*caller,T28* C);
T6 r112is_equal(se_dump_stack*caller,T112* C,T0* a1);
void r112make(se_dump_stack*caller,T112* C,T0* a1);
T6 r112standard_is_equal(se_dump_stack*caller,T112* C,T0* a1);
void r112execute(se_dump_stack*caller,T112* C);
T0* r112twin(se_dump_stack*caller,T112* C);
T6 r137is_equal(se_dump_stack*caller,T137* C,T0* a1);
void r137make(se_dump_stack*caller,T137* C,T0* a1);
T6 r137standard_is_equal(se_dump_stack*caller,T137* C,T0* a1);
void r137execute(se_dump_stack*caller,T137* C);
T0* r137twin(se_dump_stack*caller,T137* C);
void r74disconnect(se_dump_stack*caller,T74* C);
T6 r74is_equal(se_dump_stack*caller,T74* C,T0* a1);
T6 r74is_symmetric(se_dump_stack*caller,T74* C);
void r74make(se_dump_stack*caller,T74* C);
void r74put_xy(se_dump_stack*caller,T74* C,T2 a1,T2 a2);
T6 r74standard_is_equal(se_dump_stack*caller,T74* C,T0* a1);
void r74make_server_bottom(se_dump_stack*caller,T74* C);
void r74count_neighbours(se_dump_stack*caller,T74* C);
T0* r74twin(se_dump_stack*caller,T74* C);
void r74connect(se_dump_stack*caller,T74* C);
void r74make_server_top(se_dump_stack*caller,T74* C);
T6 r125is_equal(se_dump_stack*caller,T125* C,T0* a1);
void r125make(se_dump_stack*caller,T125* C,T0* a1);
T6 r125standard_is_equal(se_dump_stack*caller,T125* C,T0* a1);
void r125execute(se_dump_stack*caller,T125* C);
T0* r125twin(se_dump_stack*caller,T125* C);
T6 r138is_equal(se_dump_stack*caller,T138* C,T0* a1);
void r138make(se_dump_stack*caller,T138* C,T0* a1);
T6 r138standard_is_equal(se_dump_stack*caller,T138* C,T0* a1);
void r138execute(se_dump_stack*caller,T138* C);
T0* r138twin(se_dump_stack*caller,T138* C);
void r146disconnect(se_dump_stack*caller,T146* C);
T6 r146is_equal(se_dump_stack*caller,T146* C,T0* a1);
T6 r146is_connected(se_dump_stack*caller,T146* C);
T6 r146standard_is_equal(se_dump_stack*caller,T146* C,T0* a1);
void r146connect_to(se_dump_stack*caller,T146* C,T0* a1);
T0* r146twin(se_dump_stack*caller,T146* C);
void r146put_character(se_dump_stack*caller,T146* C,T3 a1);
void r146put_string(se_dump_stack*caller,T146* C,T0* a1);
T6 r116is_equal(se_dump_stack*caller,T116* C,T0* a1);
void r116make(se_dump_stack*caller,T116* C,T0* a1);
T6 r116standard_is_equal(se_dump_stack*caller,T116* C,T0* a1);
void r116execute(se_dump_stack*caller,T116* C);
T0* r116twin(se_dump_stack*caller,T116* C);
T6 r136is_equal(se_dump_stack*caller,T136* C,T0* a1);
void r136make(se_dump_stack*caller,T136* C,T0* a1);
T6 r136standard_is_equal(se_dump_stack*caller,T136* C,T0* a1);
void r136execute(se_dump_stack*caller,T136* C);
T0* r136twin(se_dump_stack*caller,T136* C);
T6 r57is_equal(se_dump_stack*caller,T57* C,T0* a1);
void r57make(se_dump_stack*caller,T57* C);
T6 r57standard_is_equal(se_dump_stack*caller,T57* C,T0* a1);
T0* r57twin(se_dump_stack*caller,T57* C);
void r57put_character(se_dump_stack*caller,T57* C,T3 a1);
void r57put_string(se_dump_stack*caller,T57* C,T0* a1);
T0* r89make_quit(se_dump_stack*caller);
T0* r89make_keydown(se_dump_stack*caller,T2 a1,T2 a2);
T0* r89make_mbdown(se_dump_stack*caller,T2 a1,T2 a2,T2 a3,T2 a4);
T2 r108prime_number_ceiling(se_dump_stack*caller,T2 a1);
void r102set_first(se_dump_stack*caller,T102* C,T0* a1);
T2 r22hour(se_dump_stack*caller,T22* C);
T2 r22time_mode(se_dump_stack*caller);
extern T0*oBC22time_mode_memo;
extern int fBC22time_mode_memo;
T0* r22time_mode_memo(se_dump_stack*caller);
T2 r22minute(se_dump_stack*caller,T22* C);
void r22update(se_dump_stack*caller,T22* C);
T2 r22second(se_dump_stack*caller,T22* C);
void r16make_options_window(se_dump_stack*caller,T16* C);
void r16reset_score(se_dump_stack*caller,T16* C);
extern T0*oBC18blue;
extern int fBC18blue;
T0* r16blue(se_dump_stack*caller);
T0* r16poll_event(se_dump_stack*caller,T16* C);
void r16make_newhs_window(se_dump_stack*caller,T16* C);
void r16use_setting(se_dump_stack*caller,T16* C,T0* a1);
void r16scramble_board(se_dump_stack*caller,T16* C);
void r16check_connections(se_dump_stack*caller,T16* C);
void r16handle_event(se_dump_stack*caller,T16* C,T0* a1);
void r16close_current_window(se_dump_stack*caller,T16* C);
void r16new_game(se_dump_stack*caller,T16* C);
void r16main_loop(se_dump_stack*caller,T16* C);
T6 r16is_surrounded(se_dump_stack*caller,T16* C,T0* a1);
void r16options_ok(se_dump_stack*caller,T16* C);
T0* r16config(se_dump_stack*caller);
T6 r16is_equal(se_dump_stack*caller,T16* C,T0* a1);
T2 r16maybe_wrapx(se_dump_stack*caller,T16* C,T2 a1);
void r16draw_board(se_dump_stack*caller,T16* C);
void r16handle_mbdown(se_dump_stack*caller,T16* C,T0* a1);
T2 r16maybe_wrapy(se_dump_stack*caller,T16* C,T2 a1);
void r16draw_tile(se_dump_stack*caller,T16* C,T0* a1);
T6 r16is_victorious(se_dump_stack*caller,T16* C);
void r16blank_screen(se_dump_stack*caller,T16* C);
void r16add_widget(se_dump_stack*caller,T16* C,T0* a1,T2 a2,T2 a3);
void r16show_hs(se_dump_stack*caller,T16* C);
void r16make_hs_window(se_dump_stack*caller,T16* C);
void r16update_best_image(se_dump_stack*caller,T16* C);
extern T0*oBC18darkpurple;
extern int fBC18darkpurple;
T0* r16darkpurple(se_dump_stack*caller);
void r16options(se_dump_stack*caller,T16* C);
void r16try_extend(se_dump_stack*caller,T16* C,T0* a1,T2 a2);
T2 r16servertopi(se_dump_stack*caller,T16* C);
T2 r16servertopj(se_dump_stack*caller,T16* C);
void r16make(se_dump_stack*caller,T16* C);
void r16fill_rect(se_dump_stack*caller,T16* C,T2 a1,T2 a2,T2 a3,T2 a4,T0* a5);
void r16rotatecw(se_dump_stack*caller,T16* C,T2 a1,T2 a2);
/* Extra external prototype for line 916 of ./netwalk.e:*/
void ext_init(void);
void r16ext_init(se_dump_stack*caller);
/* Extra external prototype for line 920 of ./netwalk.e:*/
void* ext_poll_event(int a1);
T0* r16ext_poll_event(se_dump_stack*caller,int a1);
T6 r16standard_is_equal(se_dump_stack*caller,T16* C,T0* a1);
/* Extra external prototype for line 924 of ./netwalk.e:*/
T2 ext_get_ticks(void);
T2 r16get_ticks(se_dump_stack*caller);
/* Extra external prototype for line 715 of ./netwalk.e:*/
void ext_fill_rect(T2 a1,T2 a2,T2 a3,T2 a4,T2 a5);
void r16ext_fill_rect(se_dump_stack*caller,T2 a1,T2 a2,T2 a3,T2 a4,T2 a5);
void r16place_tile(se_dump_stack*caller,T16* C,T0* a1,T2 a2,T2 a3);
T0* r16mainfont(se_dump_stack*caller,T16* C);
T2 r16dir_opposite(se_dump_stack*caller,T16* C,T2 a1);
void r16generate_board(se_dump_stack*caller,T16* C);
T0* r16green(se_dump_stack*caller);
T2 r16height(se_dump_stack*caller,T16* C);
T0* r16get_neighbour(se_dump_stack*caller,T16* C,T0* a1,T2 a2);
void r16quit(se_dump_stack*caller,T16* C);
/* Extra external prototype for line 928 of ./netwalk.e:*/
void ext_update_screen(void);
void r16ext_update_screen(se_dump_stack*caller);
void r16rotateccw(se_dump_stack*caller,T16* C,T2 a1,T2 a2);
void r16preprocess_board(se_dump_stack*caller,T16* C);
void r16update_time_image(se_dump_stack*caller,T16* C);
void r16draw_border(se_dump_stack*caller,T16* C);
extern T0*oBC18darkred;
extern int fBC18darkred;
T0* r16darkred(se_dump_stack*caller);
void r16newhs_ok(se_dump_stack*caller,T16* C);
T0* r16twin(se_dump_stack*caller,T16* C);
void r16hiscore_check(se_dump_stack*caller,T16* C);
T0* r16white(se_dump_stack*caller);
T2 r16width(se_dump_stack*caller,T16* C);
extern T0*oBC18cyan;
extern int fBC18cyan;
T0* r16cyan(se_dump_stack*caller);
T0* r16font(se_dump_stack*caller,T16* C);
T6 r16allow_wrap(se_dump_stack*caller,T16* C);
T6 r16on_board(se_dump_stack*caller,T16* C,T2 a1,T2 a2);
extern T0*oBC16win_image;
extern int fBC16win_image;
T0* r16win_image(se_dump_stack*caller,T16* C);
void r16tally_move(se_dump_stack*caller,T16* C);
T0* r16black(se_dump_stack*caller);
extern T16*eiffel_root_object;
extern int se_argc;
extern char**se_argv;
#define SE_MAXID 157
extern T7* g[];
extern T7* t[];
extern char* p[];
extern void(*se_prinT[157])(void**);
void initialize_eiffel_runtime(int argc,char*argv[]);
extern T7*ms54_395678;
extern T7*ms2_117797837;
T7*se_ms(int c,char*e);
T7*se_string(char*e);
void se_msi1(void);
void manifest_string_mark1(void);
void once_function_mark(void);
void gc_start(void);
typedef struct B57 gc57;
struct B57{T57 object;union {int flag;gc57*next;} header;};
extern gc57*store57;
extern int store_left57;
extern fsoc*store_chunk57;
extern gc57*gc_free57;
typedef struct B114 gc114;
struct B114{T114 object;union {int flag;gc114*next;} header;};
extern gc114*store114;
extern int store_left114;
extern fsoc*store_chunk114;
extern gc114*gc_free114;
typedef struct B135 gc135;
struct B135{T135 object;union {int flag;gc135*next;} header;};
extern gc135*store135;
extern int store_left135;
extern fsoc*store_chunk135;
extern gc135*gc_free135;
typedef struct B130 gc130;
struct B130{T130 object;union {int flag;gc130*next;} header;};
extern gc130*store130;
extern int store_left130;
extern fsoc*store_chunk130;
extern gc130*gc_free130;
typedef struct B47 gc47;
struct B47{T47 object;union {int flag;gc47*next;} header;};
extern gc47*store47;
extern int store_left47;
extern fsoc*store_chunk47;
extern gc47*gc_free47;
typedef struct B75 gc75;
struct B75{T75 object;union {int flag;gc75*next;} header;};
extern gc75*store75;
extern int store_left75;
extern fsoc*store_chunk75;
extern gc75*gc_free75;
typedef struct B41 gc41;
struct B41{T41 object;union {int flag;gc41*next;} header;};
extern gc41*store41;
extern int store_left41;
extern fsoc*store_chunk41;
extern gc41*gc_free41;
typedef struct B43 gc43;
struct B43{T43 object;union {int flag;gc43*next;} header;};
extern gc43*store43;
extern int store_left43;
extern fsoc*store_chunk43;
extern gc43*gc_free43;
typedef struct B87 gc87;
struct B87{T87 object;union {int flag;gc87*next;} header;};
extern gc87*store87;
extern int store_left87;
extern fsoc*store_chunk87;
extern gc87*gc_free87;
typedef struct B83 gc83;
struct B83{T83 object;union {int flag;gc83*next;} header;};
extern gc83*store83;
extern int store_left83;
extern fsoc*store_chunk83;
extern gc83*gc_free83;
typedef struct B117 gc117;
struct B117{T117 object;union {int flag;gc117*next;} header;};
extern gc117*store117;
extern int store_left117;
extern fsoc*store_chunk117;
extern gc117*gc_free117;
extern na_env na_env82;
typedef struct B126 gc126;
struct B126{T126 object;union {int flag;gc126*next;} header;};
extern gc126*store126;
extern int store_left126;
extern fsoc*store_chunk126;
extern gc126*gc_free126;
extern na_env na_env49;
#define gc_mark111(x) gc_mark_agent((x))
typedef struct B54 gc54;
struct B54{T54 object;union {int flag;gc54*next;} header;};
extern gc54*store54;
extern int store_left54;
extern fsoc*store_chunk54;
extern gc54*gc_free54;
typedef struct B102 gc102;
struct B102{T102 object;union {int flag;gc102*next;} header;};
extern gc102*store102;
extern int store_left102;
extern fsoc*store_chunk102;
extern gc102*gc_free102;
typedef struct B107 gc107;
struct B107{T107 object;union {int flag;gc107*next;} header;};
extern gc107*store107;
extern int store_left107;
extern fsoc*store_chunk107;
extern gc107*gc_free107;
typedef struct B121 gc121;
struct B121{T121 object;union {int flag;gc121*next;} header;};
extern gc121*store121;
extern int store_left121;
extern fsoc*store_chunk121;
extern gc121*gc_free121;
#define gc_mark124(x) gc_mark_agent((x))
typedef struct B120 gc120;
struct B120{T120 object;union {int flag;gc120*next;} header;};
extern gc120*store120;
extern int store_left120;
extern fsoc*store_chunk120;
extern gc120*gc_free120;
extern na_env na_env76;
#define gc_mark149(x) gc_mark_agent((x))
typedef struct B53 gc53;
struct B53{T53 object;union {int flag;gc53*next;} header;};
extern gc53*store53;
extern int store_left53;
extern fsoc*store_chunk53;
extern gc53*gc_free53;
typedef struct B50 gc50;
struct B50{T50 object;union {int flag;gc50*next;} header;};
extern gc50*store50;
extern int store_left50;
extern fsoc*store_chunk50;
extern gc50*gc_free50;
typedef struct B122 gc122;
struct B122{T122 object;union {int flag;gc122*next;} header;};
extern gc122*store122;
extern int store_left122;
extern fsoc*store_chunk122;
extern gc122*gc_free122;
typedef struct B151 gc151;
struct B151{T151 object;union {int flag;gc151*next;} header;};
extern gc151*store151;
extern int store_left151;
extern fsoc*store_chunk151;
extern gc151*gc_free151;
typedef struct B77 gc77;
struct B77{T77 object;union {int flag;gc77*next;} header;};
extern gc77*store77;
extern int store_left77;
extern fsoc*store_chunk77;
extern gc77*gc_free77;
typedef struct B51 gc51;
struct B51{T51 object;union {int flag;gc51*next;} header;};
extern gc51*store51;
extern int store_left51;
extern fsoc*store_chunk51;
extern gc51*gc_free51;
typedef struct B97 gc97;
struct B97{T97 object;union {int flag;gc97*next;} header;};
extern gc97*store97;
extern int store_left97;
extern fsoc*store_chunk97;
extern gc97*gc_free97;
typedef struct B99 gc99;
struct B99{T99 object;union {int flag;gc99*next;} header;};
extern gc99*store99;
extern int store_left99;
extern fsoc*store_chunk99;
extern gc99*gc_free99;
typedef struct B80 gc80;
struct B80{T80 object;union {int flag;gc80*next;} header;};
extern gc80*store80;
extern int store_left80;
extern fsoc*store_chunk80;
extern gc80*gc_free80;
typedef struct B140 gc140;
struct B140{T140 object;union {int flag;gc140*next;} header;};
extern gc140*store140;
extern int store_left140;
extern fsoc*store_chunk140;
extern gc140*gc_free140;
typedef struct B118 gc118;
struct B118{T118 object;union {int flag;gc118*next;} header;};
extern gc118*store118;
extern int store_left118;
extern fsoc*store_chunk118;
extern gc118*gc_free118;
typedef struct B113 gc113;
struct B113{T113 object;union {int flag;gc113*next;} header;};
extern gc113*store113;
extern int store_left113;
extern fsoc*store_chunk113;
extern gc113*gc_free113;
typedef struct B55 gc55;
struct B55{T55 object;union {int flag;gc55*next;} header;};
extern gc55*store55;
extern int store_left55;
extern fsoc*store_chunk55;
extern gc55*gc_free55;
extern na_env na_env69;
typedef struct B65 gc65;
struct B65{T65 object;union {int flag;gc65*next;} header;};
extern gc65*store65;
extern int store_left65;
extern fsoc*store_chunk65;
extern gc65*gc_free65;
typedef struct B128 gc128;
struct B128{T128 object;union {int flag;gc128*next;} header;};
extern gc128*store128;
extern int store_left128;
extern fsoc*store_chunk128;
extern gc128*gc_free128;
typedef struct B105 gc105;
struct B105{T105 object;union {int flag;gc105*next;} header;};
extern gc105*store105;
extern int store_left105;
extern fsoc*store_chunk105;
extern gc105*gc_free105;
typedef struct B68 gc68;
struct B68{T68 object;union {int flag;gc68*next;} header;};
extern gc68*store68;
extern int store_left68;
extern fsoc*store_chunk68;
extern gc68*gc_free68;
typedef struct B129 gc129;
struct B129{T129 object;union {int flag;gc129*next;} header;};
extern gc129*store129;
extern int store_left129;
extern fsoc*store_chunk129;
extern gc129*gc_free129;
typedef struct B153 gc153;
struct B153{T153 object;union {int flag;gc153*next;} header;};
extern gc153*store153;
extern int store_left153;
extern fsoc*store_chunk153;
extern gc153*gc_free153;
typedef struct B45 gc45;
struct B45{T45 object;union {int flag;gc45*next;} header;};
extern gc45*store45;
extern int store_left45;
extern fsoc*store_chunk45;
extern gc45*gc_free45;
typedef struct B96 gc96;
struct B96{T96 object;union {int flag;gc96*next;} header;};
extern gc96*store96;
extern int store_left96;
extern fsoc*store_chunk96;
extern gc96*gc_free96;
typedef struct B7 gc7;
struct B7{T7 object;union {int flag;gc7*next;} header;};
extern gc7*store7;
extern int store_left7;
extern fsoc*store_chunk7;
extern gc7*gc_free7;
typedef struct B39 gc39;
struct B39{T39 object;union {int flag;gc39*next;} header;};
extern gc39*store39;
extern int store_left39;
extern fsoc*store_chunk39;
extern gc39*gc_free39;
typedef struct B127 gc127;
struct B127{T127 object;union {int flag;gc127*next;} header;};
extern gc127*store127;
extern int store_left127;
extern fsoc*store_chunk127;
extern gc127*gc_free127;
extern na_env na_env9;
typedef struct B98 gc98;
struct B98{T98 object;union {int flag;gc98*next;} header;};
extern gc98*store98;
extern int store_left98;
extern fsoc*store_chunk98;
extern gc98*gc_free98;
#define gc_mark95(x) gc_mark_agent((x))
#define gc_mark134(x) gc_mark_agent((x))
#define gc_mark109(x) gc_mark_agent((x))
typedef struct B104 gc104;
struct B104{T104 object;union {int flag;gc104*next;} header;};
extern gc104*store104;
extern int store_left104;
extern fsoc*store_chunk104;
extern gc104*gc_free104;
typedef struct B131 gc131;
struct B131{T131 object;union {int flag;gc131*next;} header;};
extern gc131*store131;
extern int store_left131;
extern fsoc*store_chunk131;
extern gc131*gc_free131;
typedef struct B28 gc28;
struct B28{T28 object;union {int flag;gc28*next;} header;};
extern gc28*store28;
extern int store_left28;
extern fsoc*store_chunk28;
extern gc28*gc_free28;
typedef struct B112 gc112;
struct B112{T112 object;union {int flag;gc112*next;} header;};
extern gc112*store112;
extern int store_left112;
extern fsoc*store_chunk112;
extern gc112*gc_free112;
typedef struct B67 gc67;
struct B67{T67 object;union {int flag;gc67*next;} header;};
extern gc67*store67;
extern int store_left67;
extern fsoc*store_chunk67;
extern gc67*gc_free67;
typedef struct B137 gc137;
struct B137{T137 object;union {int flag;gc137*next;} header;};
extern gc137*store137;
extern int store_left137;
extern fsoc*store_chunk137;
extern gc137*gc_free137;
#define gc_mark115(x) gc_mark_agent((x))
typedef struct B74 gc74;
struct B74{T74 object;union {int flag;gc74*next;} header;};
extern gc74*store74;
extern int store_left74;
extern fsoc*store_chunk74;
extern gc74*gc_free74;
typedef struct B64 gc64;
struct B64{T64 object;union {int flag;gc64*next;} header;};
extern gc64*store64;
extern int store_left64;
extern fsoc*store_chunk64;
extern gc64*gc_free64;
typedef struct B16 gc16;
struct B16{T16 object;union {int flag;gc16*next;} header;};
extern gc16*store16;
extern int store_left16;
extern fsoc*store_chunk16;
extern gc16*gc_free16;
typedef struct B125 gc125;
struct B125{T125 object;union {int flag;gc125*next;} header;};
extern gc125*store125;
extern int store_left125;
extern fsoc*store_chunk125;
extern gc125*gc_free125;
typedef struct B86 gc86;
struct B86{T86 object;union {int flag;gc86*next;} header;};
extern gc86*store86;
extern int store_left86;
extern fsoc*store_chunk86;
extern gc86*gc_free86;
typedef struct B138 gc138;
struct B138{T138 object;union {int flag;gc138*next;} header;};
extern gc138*store138;
extern int store_left138;
extern fsoc*store_chunk138;
extern gc138*gc_free138;
extern na_env na_env85;
typedef struct B146 gc146;
struct B146{T146 object;union {int flag;gc146*next;} header;};
extern gc146*store146;
extern int store_left146;
extern fsoc*store_chunk146;
extern gc146*gc_free146;
typedef struct B106 gc106;
struct B106{T106 object;union {int flag;gc106*next;} header;};
extern gc106*store106;
extern int store_left106;
extern fsoc*store_chunk106;
extern gc106*gc_free106;
typedef struct B66 gc66;
struct B66{T66 object;union {int flag;gc66*next;} header;};
extern gc66*store66;
extern int store_left66;
extern fsoc*store_chunk66;
extern gc66*gc_free66;
typedef struct B116 gc116;
struct B116{T116 object;union {int flag;gc116*next;} header;};
extern gc116*store116;
extern int store_left116;
extern fsoc*store_chunk116;
extern gc116*gc_free116;
typedef struct B132 gc132;
struct B132{T132 object;union {int flag;gc132*next;} header;};
extern gc132*store132;
extern int store_left132;
extern fsoc*store_chunk132;
extern gc132*gc_free132;
typedef struct B136 gc136;
struct B136{T136 object;union {int flag;gc136*next;} header;};
extern gc136*store136;
extern int store_left136;
extern fsoc*store_chunk136;
extern gc136*gc_free136;
extern na_env na_env133;
void gc_sweep57(fsoc*c);
void gc_mark57(T57*o);
void gc_align_mark57(fsoc*c,gc57*p);
extern fsoc H57;
T57*new57(void);
void gc_sweep114(fsoc*c);
void gc_mark114(T114*o);
void gc_align_mark114(fsoc*c,gc114*p);
extern fsoc H114;
T114*new114(void);
void gc_sweep135(fsoc*c);
void gc_mark135(T135*o);
void gc_align_mark135(fsoc*c,gc135*p);
extern fsoc H135;
T135*new135(void);
void gc_sweep130(fsoc*c);
void gc_mark130(T130*o);
void gc_align_mark130(fsoc*c,gc130*p);
extern fsoc H130;
T130*new130(void);
void gc_sweep47(fsoc*c);
void gc_mark47(T47*o);
void gc_align_mark47(fsoc*c,gc47*p);
extern fsoc H47;
T47*new47(void);
void gc_sweep75(fsoc*c);
void gc_mark75(T75*o);
void gc_align_mark75(fsoc*c,gc75*p);
extern fsoc H75;
T75*new75(void);
void gc_sweep41(fsoc*c);
void gc_mark41(T41*o);
void gc_align_mark41(fsoc*c,gc41*p);
extern fsoc H41;
T41*new41(void);
void gc_sweep43(fsoc*c);
void gc_mark43(T43*o);
void gc_align_mark43(fsoc*c,gc43*p);
extern fsoc H43;
T43*new43(void);
void gc_sweep87(fsoc*c);
void gc_mark87(T87*o);
void gc_align_mark87(fsoc*c,gc87*p);
extern fsoc H87;
T87*new87(void);
void gc_sweep83(fsoc*c);
void gc_mark83(T83*o);
void gc_align_mark83(fsoc*c,gc83*p);
extern fsoc H83;
T83*new83(void);
void gc_sweep117(fsoc*c);
void gc_mark117(T117*o);
void gc_align_mark117(fsoc*c,gc117*p);
extern fsoc H117;
T117*new117(void);
void gc_mark82(T82 o);
T82 new82(int size);
void gc_sweep126(fsoc*c);
void gc_mark126(T126*o);
void gc_align_mark126(fsoc*c,gc126*p);
extern fsoc H126;
T126*new126(void);
void gc_mark49(T49 o);
T49 new49(int size);
void gc_sweep54(fsoc*c);
void gc_mark54(T54*o);
void gc_align_mark54(fsoc*c,gc54*p);
extern fsoc H54;
T54*new54(void);
void gc_sweep102(fsoc*c);
void gc_mark102(T102*o);
void gc_align_mark102(fsoc*c,gc102*p);
extern fsoc H102;
T102*new102(void);
void gc_sweep107(fsoc*c);
void gc_mark107(T107*o);
void gc_align_mark107(fsoc*c,gc107*p);
extern fsoc H107;
T107*new107(void);
void gc_sweep121(fsoc*c);
void gc_mark121(T121*o);
void gc_align_mark121(fsoc*c,gc121*p);
extern fsoc H121;
T121*new121(void);
void gc_sweep120(fsoc*c);
void gc_mark120(T120*o);
void gc_align_mark120(fsoc*c,gc120*p);
extern fsoc H120;
T120*new120(void);
void gc_mark76(T76 o);
T76 new76(int size);
void gc_sweep53(fsoc*c);
void gc_mark53(T53*o);
void gc_align_mark53(fsoc*c,gc53*p);
extern fsoc H53;
T53*new53(void);
void gc_sweep50(fsoc*c);
void gc_mark50(T50*o);
void gc_align_mark50(fsoc*c,gc50*p);
extern fsoc H50;
T50*new50(void);
void gc_sweep122(fsoc*c);
void gc_mark122(T122*o);
void gc_align_mark122(fsoc*c,gc122*p);
extern fsoc H122;
T122*new122(void);
void gc_sweep151(fsoc*c);
void gc_mark151(T151*o);
void gc_align_mark151(fsoc*c,gc151*p);
extern fsoc H151;
T151*new151(void);
void gc_sweep77(fsoc*c);
void gc_mark77(T77*o);
void gc_align_mark77(fsoc*c,gc77*p);
extern fsoc H77;
T77*new77(void);
void gc_sweep51(fsoc*c);
void gc_mark51(T51*o);
void gc_align_mark51(fsoc*c,gc51*p);
extern fsoc H51;
T51*new51(void);
void gc_sweep97(fsoc*c);
void gc_mark97(T97*o);
void gc_align_mark97(fsoc*c,gc97*p);
extern fsoc H97;
T97*new97(void);
void gc_sweep99(fsoc*c);
void gc_mark99(T99*o);
void gc_align_mark99(fsoc*c,gc99*p);
extern fsoc H99;
T99*new99(void);
void gc_sweep80(fsoc*c);
void gc_mark80(T80*o);
void gc_align_mark80(fsoc*c,gc80*p);
extern fsoc H80;
T80*new80(void);
void gc_sweep140(fsoc*c);
void gc_mark140(T140*o);
void gc_align_mark140(fsoc*c,gc140*p);
extern fsoc H140;
T140*new140(void);
void gc_sweep118(fsoc*c);
void gc_mark118(T118*o);
void gc_align_mark118(fsoc*c,gc118*p);
extern fsoc H118;
T118*new118(void);
void gc_sweep113(fsoc*c);
void gc_mark113(T113*o);
void gc_align_mark113(fsoc*c,gc113*p);
extern fsoc H113;
T113*new113(void);
void gc_sweep55(fsoc*c);
void gc_mark55(T55*o);
void gc_align_mark55(fsoc*c,gc55*p);
extern fsoc H55;
T55*new55(void);
void gc_mark69(T69 o);
T69 new69(int size);
void gc_sweep65(fsoc*c);
void gc_mark65(T65*o);
void gc_align_mark65(fsoc*c,gc65*p);
extern fsoc H65;
T65*new65(void);
void gc_sweep128(fsoc*c);
void gc_mark128(T128*o);
void gc_align_mark128(fsoc*c,gc128*p);
extern fsoc H128;
T128*new128(void);
void gc_sweep105(fsoc*c);
void gc_mark105(T105*o);
void gc_align_mark105(fsoc*c,gc105*p);
extern fsoc H105;
T105*new105(void);
void gc_sweep68(fsoc*c);
void gc_mark68(T68*o);
void gc_align_mark68(fsoc*c,gc68*p);
extern fsoc H68;
T68*new68(void);
void gc_sweep129(fsoc*c);
void gc_mark129(T129*o);
void gc_align_mark129(fsoc*c,gc129*p);
extern fsoc H129;
T129*new129(void);
void gc_sweep153(fsoc*c);
void gc_mark153(T153*o);
void gc_align_mark153(fsoc*c,gc153*p);
extern fsoc H153;
T153*new153(void);
void gc_sweep45(fsoc*c);
void gc_mark45(T45*o);
void gc_align_mark45(fsoc*c,gc45*p);
extern fsoc H45;
T45*new45(void);
void gc_sweep96(fsoc*c);
void gc_mark96(T96*o);
void gc_align_mark96(fsoc*c,gc96*p);
extern fsoc H96;
T96*new96(void);
void gc_sweep7(fsoc*c);
void gc_mark7(T7*o);
void gc_align_mark7(fsoc*c,gc7*p);
extern fsoc H7;
T7*new7(void);
void gc_sweep39(fsoc*c);
void gc_mark39(T39*o);
void gc_align_mark39(fsoc*c,gc39*p);
extern fsoc H39;
T39*new39(void);
void gc_sweep127(fsoc*c);
void gc_mark127(T127*o);
void gc_align_mark127(fsoc*c,gc127*p);
extern fsoc H127;
T127*new127(void);
void gc_mark9(T9 o);
T9 new9(int size);
void gc_sweep98(fsoc*c);
void gc_mark98(T98*o);
void gc_align_mark98(fsoc*c,gc98*p);
extern fsoc H98;
T98*new98(void);
void gc_sweep104(fsoc*c);
void gc_mark104(T104*o);
void gc_align_mark104(fsoc*c,gc104*p);
extern fsoc H104;
T104*new104(void);
void gc_sweep131(fsoc*c);
void gc_mark131(T131*o);
void gc_align_mark131(fsoc*c,gc131*p);
extern fsoc H131;
T131*new131(void);
void gc_sweep28(fsoc*c);
void gc_mark28(T28*o);
void gc_align_mark28(fsoc*c,gc28*p);
extern fsoc H28;
T28*new28(void);
void gc_sweep112(fsoc*c);
void gc_mark112(T112*o);
void gc_align_mark112(fsoc*c,gc112*p);
extern fsoc H112;
T112*new112(void);
void gc_sweep67(fsoc*c);
void gc_mark67(T67*o);
void gc_align_mark67(fsoc*c,gc67*p);
extern fsoc H67;
T67*new67(void);
void gc_sweep137(fsoc*c);
void gc_mark137(T137*o);
void gc_align_mark137(fsoc*c,gc137*p);
extern fsoc H137;
T137*new137(void);
void gc_sweep74(fsoc*c);
void gc_mark74(T74*o);
void gc_align_mark74(fsoc*c,gc74*p);
extern fsoc H74;
T74*new74(void);
void gc_sweep64(fsoc*c);
void gc_mark64(T64*o);
void gc_align_mark64(fsoc*c,gc64*p);
extern fsoc H64;
T64*new64(void);
void gc_sweep16(fsoc*c);
void gc_mark16(T16*o);
void gc_align_mark16(fsoc*c,gc16*p);
extern fsoc H16;
T16*new16(void);
void gc_sweep125(fsoc*c);
void gc_mark125(T125*o);
void gc_align_mark125(fsoc*c,gc125*p);
extern fsoc H125;
T125*new125(void);
void gc_sweep86(fsoc*c);
void gc_mark86(T86*o);
void gc_align_mark86(fsoc*c,gc86*p);
extern fsoc H86;
T86*new86(void);
void gc_sweep138(fsoc*c);
void gc_mark138(T138*o);
void gc_align_mark138(fsoc*c,gc138*p);
extern fsoc H138;
T138*new138(void);
void gc_mark85(T85 o);
T85 new85(int size);
void gc_sweep146(fsoc*c);
void gc_mark146(T146*o);
void gc_align_mark146(fsoc*c,gc146*p);
extern fsoc H146;
T146*new146(void);
void gc_sweep106(fsoc*c);
void gc_mark106(T106*o);
void gc_align_mark106(fsoc*c,gc106*p);
extern fsoc H106;
T106*new106(void);
void gc_sweep66(fsoc*c);
void gc_mark66(T66*o);
void gc_align_mark66(fsoc*c,gc66*p);
extern fsoc H66;
T66*new66(void);
void gc_sweep116(fsoc*c);
void gc_mark116(T116*o);
void gc_align_mark116(fsoc*c,gc116*p);
extern fsoc H116;
T116*new116(void);
void gc_sweep132(fsoc*c);
void gc_mark132(T132*o);
void gc_align_mark132(fsoc*c,gc132*p);
extern fsoc H132;
T132*new132(void);
void gc_sweep136(fsoc*c);
void gc_mark136(T136*o);
void gc_align_mark136(fsoc*c,gc136*p);
extern fsoc H136;
T136*new136(void);
void gc_mark133(T133 o);
T133 new133(int size);
void Xgc_mark29(T0*o);
void Xgc_mark25(T0*o);
void Xgc_mark30(T0*o);
void X25execute(se_dump_stack*caller,se_position position,T0*C);
T2 X70count(se_dump_stack*caller,se_position position,T0*C);
T2 X70upper(se_dump_stack*caller,se_position position,T0*C);
T0* X70item(se_dump_stack*caller,se_position position,T0*C,T2 a1);
T2 X70lower(se_dump_stack*caller,se_position position,T0*C);
void X70add_last(se_dump_stack*caller,se_position position,T0*C,T0* a1);
T6 X10is_equal(se_dump_stack*caller,se_position position,T0*C,T0* a1);
T6 X10standard_is_equal(se_dump_stack*caller,se_position position,T0*C,T0* a1);
T0* X10twin(se_dump_stack*caller,se_position position,T0*C);
void X29process_event(se_dump_stack*caller,se_position position,T0*C,T0* a1);
void X29update(se_dump_stack*caller,se_position position,T0*C);
T2 X30offsetx(se_dump_stack*caller,se_position position,T0*C);
T2 X30offsety(se_dump_stack*caller,se_position position,T0*C);
T6 X30contains(se_dump_stack*caller,se_position position,T0*C,T2 a1,T2 a2);
void X30put_xy(se_dump_stack*caller,se_position position,T0*C,T2 a1,T2 a2);
void X30put_focus(se_dump_stack*caller,se_position position,T0*C,T6 a1);
T2 X30signal_cancel(se_dump_stack*caller,se_position position,T0*C);
void X30process_event(se_dump_stack*caller,se_position position,T0*C,T0* a1);
void X30raise_signal(se_dump_stack*caller,se_position position,T0*C,T2 a1);
T2 X30signal_activate(se_dump_stack*caller,se_position position,T0*C);
void X30update(se_dump_stack*caller,se_position position,T0*C);

#ifdef __cplusplus
}
#endif
